'use strict';

var JSX9 = require('@eslint-react/jsx');
var shared = require('@eslint-react/shared');
var tools = require('@eslint-react/tools');
var types = require('@typescript-eslint/types');
var AST = require('@eslint-react/ast');
var tsPattern = require('ts-pattern');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var JSX9__namespace = /*#__PURE__*/_interopNamespace(JSX9);
var AST__namespace = /*#__PURE__*/_interopNamespace(AST);

// package.json
var name = "eslint-plugin-react-dom";
var version = "1.16.1";
var createRule = shared.createRuleForPlugin("dom");

// src/rules/no-children-in-void-dom-elements.ts
var RULE_NAME = "no-children-in-void-dom-elements";
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var no_children_in_void_dom_elements_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow passing 'children' to void DOM elements"
    },
    messages: {
      noChildrenInVoidDomElements: "A void DOM element '<{{element}} />' cannot have children."
    },
    schema: []
  },
  name: RULE_NAME,
  create(context) {
    const { components, polymorphicPropName } = shared.normalizeSettings(shared.decodeSettings(context.settings));
    return {
      JSXElement(node) {
        const openingElementNameExpression = node.openingElement;
        const jsxCtx = { getScope: (node2) => context.sourceCode.getScope(node2) };
        const elementType = JSX9__namespace.getElementType(jsxCtx, components, polymorphicPropName)(openingElementNameExpression);
        if (!elementType || !voidElements.has(elementType)) return;
        if (node.children.length > 0) {
          context.report({
            messageId: "noChildrenInVoidDomElements",
            node,
            data: {
              element: elementType
            }
          });
        }
        const { attributes } = node.openingElement;
        const initialScope = context.sourceCode.getScope(node);
        const hasAttr = (name2) => tools.O.isSome(JSX9__namespace.findPropInAttributes(attributes, initialScope)(name2));
        const hasChildrenOrDangerAttr = hasAttr("children") || hasAttr("dangerouslySetInnerHTML");
        if (hasChildrenOrDangerAttr) {
          context.report({
            messageId: "noChildrenInVoidDomElements",
            node,
            data: {
              element: elementType
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME2 = "no-dangerously-set-innerhtml";
var no_dangerously_set_innerhtml_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow when a DOM component is using 'dangerouslySetInnerHTML'"
    },
    messages: {
      noDangerouslySetInnerhtml: "Using 'dangerouslySetInnerHTML' may have security implications."
    },
    schema: []
  },
  name: RULE_NAME2,
  create(context) {
    return {
      JSXElement(node) {
        const initialScope = context.sourceCode.getScope(node);
        const maybeDanger = JSX9__namespace.findPropInAttributes(node.openingElement.attributes, initialScope)(
          "dangerouslySetInnerHTML"
        );
        if (tools.O.isSome(maybeDanger)) {
          context.report({
            messageId: "noDangerouslySetInnerhtml",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME3 = "no-dangerously-set-innerhtml-with-children";
function firstChildIsText(node) {
  const [firstChild] = node.children;
  return node.children.length > 0 && !tools.isNullable(firstChild) && !JSX9__namespace.isLineBreak(firstChild);
}
var no_dangerously_set_innerhtml_with_children_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow when a DOM component is using both 'children' and 'dangerouslySetInnerHTML'"
    },
    messages: {
      noDangerouslySetInnerhtmlWithChildren: "A DOM component cannot use both 'children' and 'dangerouslySetInnerHTML'."
    },
    schema: []
  },
  name: RULE_NAME3,
  create(context) {
    return {
      JSXElement(node) {
        const initialScope = context.sourceCode.getScope(node);
        const hasChildrenWithIn = () => node.children.length > 0 && firstChildIsText(node);
        const hasChildrenProp = () => JSX9__namespace.hasProp(node.openingElement.attributes, "children", initialScope);
        const hasDanger = () => JSX9__namespace.hasProp(node.openingElement.attributes, "dangerouslySetInnerHTML", initialScope);
        if (!(hasChildrenWithIn() || hasChildrenProp()) || !hasDanger()) return;
        context.report({
          messageId: "noDangerouslySetInnerhtmlWithChildren",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME4 = "no-find-dom-node";
var no_find_dom_node_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow 'findDOMNode'"
    },
    messages: {
      noFindDomNode: "[Deprecated] Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    return {
      CallExpression(node) {
        const { callee } = node;
        switch (callee.type) {
          case types.AST_NODE_TYPES.Identifier:
            if (callee.name === "findDOMNode") {
              context.report({ messageId: "noFindDomNode", node });
            }
            return;
          case types.AST_NODE_TYPES.MemberExpression:
            if (callee.property.type === types.AST_NODE_TYPES.Identifier && callee.property.name === "findDOMNode") {
              context.report({ messageId: "noFindDomNode", node });
            }
            return;
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME5 = "no-missing-button-type";
var no_missing_button_type_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce that button component have an explicit 'type' attribute"
    },
    messages: {
      noMissingButtonType: "Add missing 'type' attribute on 'button' component."
    },
    schema: []
  },
  name: RULE_NAME5,
  create(context) {
    const { components, polymorphicPropName } = shared.normalizeSettings(shared.decodeSettings(context.settings));
    return {
      JSXElement(node) {
        const jsxCtx = { getScope: (node2) => context.sourceCode.getScope(node2) };
        const elementType = JSX9__namespace.getElementType(jsxCtx, components, polymorphicPropName)(node.openingElement);
        if (elementType !== "button") return;
        const { attributes } = node.openingElement;
        const initialScope = context.sourceCode.getScope(node);
        const maybeTypeAttribute = JSX9__namespace.findPropInAttributes(attributes, initialScope)("type");
        if (tools.O.isSome(maybeTypeAttribute)) return;
        context.report({
          messageId: "noMissingButtonType",
          node: node.openingElement
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME6 = "no-missing-iframe-sandbox";
var validTypes = [
  "",
  "allow-downloads",
  "allow-downloads-without-user-activation",
  "allow-forms",
  "allow-modals",
  "allow-orientation-lock",
  "allow-pointer-lock",
  "allow-popups",
  "allow-popups-to-escape-sandbox",
  "allow-presentation",
  "allow-same-origin",
  "allow-scripts",
  "allow-storage-access-by-user-activation",
  "allow-top-navigation",
  "allow-top-navigation-by-user-activation",
  "allow-top-navigation-to-custom-protocols"
];
var no_missing_iframe_sandbox_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce that 'iframe' component have an explicit 'sandbox' attribute"
    },
    messages: {
      noMissingIframeSandbox: "Add missing 'sandbox' attribute on 'iframe' component."
    },
    schema: []
  },
  name: RULE_NAME6,
  create(context) {
    const { components, polymorphicPropName } = shared.normalizeSettings(shared.decodeSettings(context.settings));
    return {
      JSXElement(node) {
        const jsxCtx = { getScope: (node2) => context.sourceCode.getScope(node2) };
        const elementType = JSX9__namespace.getElementType(jsxCtx, components, polymorphicPropName)(node.openingElement);
        if (elementType !== "iframe") return;
        const { attributes } = node.openingElement;
        const initialScope = context.sourceCode.getScope(node);
        const maybeSandboxAttribute = JSX9__namespace.findPropInAttributes(attributes, initialScope)("sandbox");
        if (tools.O.isNone(maybeSandboxAttribute)) {
          context.report({
            messageId: "noMissingIframeSandbox",
            node: node.openingElement
          });
          return;
        }
        const sandboxAttribute = maybeSandboxAttribute.value;
        const hasValidSandbox = tools.F.pipe(
          JSX9__namespace.getPropValue(sandboxAttribute, context.sourceCode.getScope(sandboxAttribute)),
          tools.O.flatMapNullable((v) => v?.value),
          tools.O.filter(tools.isString),
          tools.O.map((value) => value.split(" ")),
          tools.O.exists((values) => values.every((value) => validTypes.some((validType) => validType === value)))
        );
        if (hasValidSandbox) return;
        context.report({
          messageId: "noMissingIframeSandbox",
          node: sandboxAttribute
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME7 = "no-namespace";
var no_namespace_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce that namespaces are not used in React elements"
    },
    messages: {
      noNamespace: "A React component '{{name}}' must not be in a namespace, as React does not support them."
    },
    schema: []
  },
  name: RULE_NAME7,
  create(context) {
    return {
      JSXOpeningElement(node) {
        const name2 = JSX9__namespace.getElementName(node);
        if (!tools.isString(name2) || !name2.includes(":")) return;
        context.report({
          messageId: "noNamespace",
          node,
          data: {
            name: name2
          }
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME8 = "no-render-return-value";
var banParentTypes = [
  types.AST_NODE_TYPES.VariableDeclarator,
  types.AST_NODE_TYPES.Property,
  types.AST_NODE_TYPES.ReturnStatement,
  types.AST_NODE_TYPES.ArrowFunctionExpression,
  types.AST_NODE_TYPES.AssignmentExpression
];
var no_render_return_value_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow usage of the return value of 'ReactDOM.render'"
    },
    messages: {
      noRenderReturnValue: "Do not depend on the return value from '{{objectName}}.render'."
    },
    schema: []
  },
  name: RULE_NAME8,
  create(context) {
    return {
      CallExpression(node) {
        const { callee, parent } = node;
        if (callee.type !== types.AST_NODE_TYPES.MemberExpression) return;
        if (callee.object.type !== types.AST_NODE_TYPES.Identifier) return;
        if (!("name" in callee.object)) return;
        const objectName = callee.object.name;
        if (objectName.toLowerCase() !== "reactdom" || callee.property.type !== types.AST_NODE_TYPES.Identifier || callee.property.name !== "render" || !AST__namespace.isOneOf(banParentTypes)(parent)) {
          return;
        }
        context.report({
          messageId: "noRenderReturnValue",
          node,
          data: {
            objectName
          }
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME9 = "no-script-url";
var no_script_url_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow 'javascript:' URLs as JSX event handler prop's value"
    },
    messages: {
      noScriptUrl: "Using a `javascript:` URL is a security risk and should be avoided."
    },
    schema: []
  },
  name: RULE_NAME9,
  create(context) {
    return {
      JSXAttribute(node) {
        if (node.name.type !== types.AST_NODE_TYPES.JSXIdentifier || !node.value) return;
        const isJavaScript = tools.F.pipe(
          JSX9__namespace.getPropValue(node, context.sourceCode.getScope(node)),
          tools.O.flatMapNullable((v) => v?.value),
          tools.O.filter(tools.isString),
          tools.O.exists((v) => shared.RE_JAVASCRIPT_PROTOCOL.test(v))
        );
        if (isJavaScript) {
          context.report({
            messageId: "noScriptUrl",
            node: node.value
          });
        }
      }
    };
  },
  defaultOptions: []
});

// src/rules/no-unknown-property.ts
var RULE_NAME10 = "no-unknown-property";
var DEFAULTS = {
  ignore: [],
  requireDataLowercase: false
};
var DOM_ATTRIBUTE_NAMES = {
  "accept-charset": "acceptCharset",
  class: "className",
  crossorigin: "crossOrigin",
  for: "htmlFor",
  "http-equiv": "httpEquiv",
  nomodule: "noModule"
};
var ATTRIBUTE_TAGS_MAP = {
  as: ["link"],
  abbr: ["th", "td"],
  align: [
    "applet",
    "caption",
    "col",
    "colgroup",
    "hr",
    "iframe",
    "img",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr"
  ],
  // deprecated, but known
  allowFullScreen: ["iframe", "video"],
  autoPictureInPicture: ["video"],
  charset: ["meta"],
  checked: ["input"],
  controls: ["audio", "video"],
  controlsList: ["audio", "video"],
  // image is required for SVG support, all other tags are HTML.
  crossOrigin: ["script", "img", "video", "audio", "link", "image"],
  disablePictureInPicture: ["video"],
  disableRemotePlayback: ["audio", "video"],
  displaystyle: ["math"],
  // https://html.spec.whatwg.org/multipage/links.html#downloading-resources
  download: ["a", "area"],
  fill: [
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill
    // Fill color
    "altGlyph",
    "circle",
    "ellipse",
    "g",
    "line",
    "marker",
    "mask",
    "path",
    "polygon",
    "polyline",
    "rect",
    "svg",
    "symbol",
    "text",
    "textPath",
    "tref",
    "tspan",
    "use",
    // Animation final state
    "animate",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "set"
  ],
  focusable: ["svg"],
  imageSizes: ["link"],
  imageSrcSet: ["link"],
  loop: ["audio", "video"],
  mozAllowFullScreen: ["iframe", "video"],
  muted: ["audio", "video"],
  noModule: ["script"],
  // Media events allowed only on audio and video tags, see https://github.com/facebook/react/blob/256aefbea1449869620fb26f6ec695536ab453f5/CHANGELOG.md#notable-enhancements
  onAbort: ["audio", "video"],
  onCanPlay: ["audio", "video"],
  onCanPlayThrough: ["audio", "video"],
  onCancel: ["dialog"],
  onClose: ["dialog"],
  onDurationChange: ["audio", "video"],
  onEmptied: ["audio", "video"],
  onEncrypted: ["audio", "video"],
  onEnded: ["audio", "video"],
  onError: ["audio", "video", "img", "link", "source", "script", "picture", "iframe"],
  onLoad: ["script", "img", "link", "picture", "iframe", "object", "source"],
  onLoadStart: ["audio", "video"],
  onLoadedData: ["audio", "video"],
  onLoadedMetadata: ["audio", "video"],
  onPause: ["audio", "video"],
  onPlay: ["audio", "video"],
  onPlaying: ["audio", "video"],
  onProgress: ["audio", "video"],
  onRateChange: ["audio", "video"],
  onResize: ["audio", "video"],
  onSeeked: ["audio", "video"],
  onSeeking: ["audio", "video"],
  onStalled: ["audio", "video"],
  onSuspend: ["audio", "video"],
  onTimeUpdate: ["audio", "video"],
  onVolumeChange: ["audio", "video"],
  onWaiting: ["audio", "video"],
  playsInline: ["video"],
  poster: ["video"],
  preload: ["audio", "video"],
  property: ["meta"],
  returnValue: ["dialog"],
  scrolling: ["iframe"],
  valign: ["tr", "td", "th", "thead", "tbody", "tfoot", "colgroup", "col"],
  // deprecated, but known
  viewBox: ["marker", "pattern", "svg", "symbol", "view"],
  webkitAllowFullScreen: ["iframe", "video"],
  webkitDirectory: ["input"]
};
var SVGDOM_ATTRIBUTE_NAMES = {
  "accent-height": "accentHeight",
  "alignment-baseline": "alignmentBaseline",
  "arabic-form": "arabicForm",
  "baseline-shift": "baselineShift",
  "cap-height": "capHeight",
  "clip-path": "clipPath",
  "clip-rule": "clipRule",
  "color-interpolation": "colorInterpolation",
  "color-interpolation-filters": "colorInterpolationFilters",
  "color-profile": "colorProfile",
  "color-rendering": "colorRendering",
  "dominant-baseline": "dominantBaseline",
  "enable-background": "enableBackground",
  "fill-opacity": "fillOpacity",
  "fill-rule": "fillRule",
  "flood-color": "floodColor",
  "flood-opacity": "floodOpacity",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-size-adjust": "fontSizeAdjust",
  "font-stretch": "fontStretch",
  "font-style": "fontStyle",
  "font-variant": "fontVariant",
  "font-weight": "fontWeight",
  "glyph-name": "glyphName",
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  "glyph-orientation-vertical": "glyphOrientationVertical",
  "horiz-adv-x": "horizAdvX",
  "horiz-origin-x": "horizOriginX",
  "image-rendering": "imageRendering",
  "letter-spacing": "letterSpacing",
  "lighting-color": "lightingColor",
  "marker-end": "markerEnd",
  "marker-mid": "markerMid",
  "marker-start": "markerStart",
  "overline-position": "overlinePosition",
  "overline-thickness": "overlineThickness",
  "paint-order": "paintOrder",
  "panose-1": "panose1",
  "pointer-events": "pointerEvents",
  "rendering-intent": "renderingIntent",
  "shape-rendering": "shapeRendering",
  "stop-color": "stopColor",
  "stop-opacity": "stopOpacity",
  "strikethrough-position": "strikethroughPosition",
  "strikethrough-thickness": "strikethroughThickness",
  "stroke-dasharray": "strokeDasharray",
  "stroke-dashoffset": "strokeDashoffset",
  "stroke-linecap": "strokeLinecap",
  "stroke-linejoin": "strokeLinejoin",
  "stroke-miterlimit": "strokeMiterlimit",
  "stroke-opacity": "strokeOpacity",
  "stroke-width": "strokeWidth",
  "text-anchor": "textAnchor",
  "text-decoration": "textDecoration",
  "text-rendering": "textRendering",
  "underline-position": "underlinePosition",
  "underline-thickness": "underlineThickness",
  "unicode-bidi": "unicodeBidi",
  "unicode-range": "unicodeRange",
  "units-per-em": "unitsPerEm",
  "v-alphabetic": "vAlphabetic",
  "v-hanging": "vHanging",
  "v-ideographic": "vIdeographic",
  "v-mathematical": "vMathematical",
  "vector-effect": "vectorEffect",
  "vert-adv-y": "vertAdvY",
  "vert-origin-x": "vertOriginX",
  "vert-origin-y": "vertOriginY",
  "word-spacing": "wordSpacing",
  "writing-mode": "writingMode",
  "x-height": "xHeight",
  "xlink:actuate": "xlinkActuate",
  "xlink:arcrole": "xlinkArcrole",
  "xlink:href": "xlinkHref",
  "xlink:role": "xlinkRole",
  "xlink:show": "xlinkShow",
  "xlink:title": "xlinkTitle",
  "xlink:type": "xlinkType",
  "xml:base": "xmlBase",
  "xml:lang": "xmlLang",
  "xml:space": "xmlSpace"
};
var DOM_PROPERTY_NAMES_ONE_WORD = [
  // Global attributes - can be used on any HTML/DOM element
  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
  "dir",
  "draggable",
  "hidden",
  "id",
  "lang",
  "nonce",
  "part",
  "slot",
  "style",
  "title",
  "translate",
  "inert",
  // Element specific attributes
  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes (includes global attributes too)
  // To be considered if these should be added also to ATTRIBUTE_TAGS_MAP
  "accept",
  "action",
  "allow",
  "alt",
  "as",
  "async",
  "buffered",
  "capture",
  "challenge",
  "cite",
  "code",
  "cols",
  "content",
  "coords",
  "csp",
  "data",
  "decoding",
  "default",
  "defer",
  "disabled",
  "form",
  "headers",
  "height",
  "high",
  "href",
  "icon",
  "importance",
  "integrity",
  "kind",
  "label",
  "language",
  "loading",
  "list",
  "loop",
  "low",
  "manifest",
  "max",
  "media",
  "method",
  "min",
  "multiple",
  "muted",
  "name",
  "open",
  "optimum",
  "pattern",
  "ping",
  "placeholder",
  "poster",
  "preload",
  "profile",
  "rel",
  "required",
  "reversed",
  "role",
  "rows",
  "sandbox",
  "scope",
  "seamless",
  "selected",
  "shape",
  "size",
  "sizes",
  "span",
  "src",
  "start",
  "step",
  "summary",
  "target",
  "type",
  "value",
  "width",
  "wmode",
  "wrap",
  // SVG attributes
  // See https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
  "accumulate",
  "additive",
  "alphabetic",
  "amplitude",
  "ascent",
  "azimuth",
  "bbox",
  "begin",
  "bias",
  "by",
  "clip",
  "color",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "direction",
  "display",
  "divisor",
  "dur",
  "dx",
  "dy",
  "elevation",
  "end",
  "exponent",
  "fill",
  "filter",
  "format",
  "from",
  "fr",
  "fx",
  "fy",
  "g1",
  "g2",
  "hanging",
  "height",
  "hreflang",
  "ideographic",
  "in",
  "in2",
  "intercept",
  "k",
  "k1",
  "k2",
  "k3",
  "k4",
  "kerning",
  "local",
  "mask",
  "mode",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "path",
  "ping",
  "points",
  "r",
  "radius",
  "rel",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "scale",
  "seed",
  "slope",
  "spacing",
  "speed",
  "stemh",
  "stemv",
  "string",
  "stroke",
  "to",
  "transform",
  "u1",
  "u2",
  "unicode",
  "values",
  "version",
  "visibility",
  "widths",
  "x",
  "x1",
  "x2",
  "xmlns",
  "y",
  "y1",
  "y2",
  "z",
  // OpenGraph meta tag attributes
  "property",
  // React specific attributes
  "ref",
  "key",
  "children",
  // Non-standard
  "results",
  "security",
  // Video specific
  "controls",
  // popovers
  "popover",
  "popovertarget",
  "popovertargetaction"
];
var DOM_PROPERTY_NAMES_TWO_WORDS = [
  // Global attributes - can be used on any HTML/DOM element
  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
  "accessKey",
  "autoCapitalize",
  "autoFocus",
  "contentEditable",
  "enterKeyHint",
  "exportParts",
  "inputMode",
  "itemID",
  "itemRef",
  "itemProp",
  "itemScope",
  "itemType",
  "spellCheck",
  "tabIndex",
  // Element specific attributes
  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes (includes global attributes too)
  // To be considered if these should be added also to ATTRIBUTE_TAGS_MAP
  "acceptCharset",
  "autoComplete",
  "autoPlay",
  "border",
  "cellPadding",
  "cellSpacing",
  "classID",
  "codeBase",
  "colSpan",
  "contextMenu",
  "dateTime",
  "encType",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "frameBorder",
  "hrefLang",
  "httpEquiv",
  "imageSizes",
  "imageSrcSet",
  "isMap",
  "keyParams",
  "keyType",
  "marginHeight",
  "marginWidth",
  "maxLength",
  "mediaGroup",
  "minLength",
  "noValidate",
  "onAnimationEnd",
  "onAnimationIteration",
  "onAnimationStart",
  "onBlur",
  "onChange",
  "onClick",
  "onContextMenu",
  "onCopy",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onCut",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onError",
  "onFocus",
  "onInput",
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  "onLoad",
  "onWheel",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onPaste",
  "onScroll",
  "onSelect",
  "onSubmit",
  "onToggle",
  "onTransitionEnd",
  "radioGroup",
  "readOnly",
  "referrerPolicy",
  "rowSpan",
  "srcDoc",
  "srcLang",
  "srcSet",
  "useMap",
  "fetchPriority",
  // SVG attributes
  // See https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
  "crossOrigin",
  "accentHeight",
  "alignmentBaseline",
  "arabicForm",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "calcMode",
  "capHeight",
  "clipPathUnits",
  "clipPath",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "diffuseConstant",
  "dominantBaseline",
  "edgeMode",
  "enableBackground",
  "fillOpacity",
  "fillRule",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "horizAdvX",
  "horizOriginX",
  "imageRendering",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "markerEnd",
  "markerMid",
  "markerStart",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "numOctaves",
  "overlinePosition",
  "overlineThickness",
  "panose1",
  "paintOrder",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "referrerPolicy",
  "refX",
  "refY",
  "rendering-intent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "shapeRendering",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textRendering",
  "textLength",
  "transformOrigin",
  "underlinePosition",
  "underlineThickness",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "vHanging",
  "vIdeographic",
  "vMathematical",
  "vectorEffect",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "viewBox",
  "viewTarget",
  "wordSpacing",
  "writingMode",
  "xHeight",
  "xChannelSelector",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlnsXlink",
  "xmlSpace",
  "yChannelSelector",
  "zoomAndPan",
  // Safari/Apple specific, no listing available
  "autoCorrect",
  // https://stackoverflow.com/questions/47985384/html-autocorrect-for-text-input-is-not-working
  "autoSave",
  // https://stackoverflow.com/questions/25456396/what-is-autosave-attribute-supposed-to-do-how-do-i-use-it
  // React specific attributes https://reactjs.org/docs/dom-elements.html#differences-in-attributes
  "className",
  "dangerouslySetInnerHTML",
  "defaultValue",
  "defaultChecked",
  "htmlFor",
  // Events' capture events
  "onBeforeInput",
  "onChange",
  "onInvalid",
  "onReset",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onResize",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting",
  "onCopyCapture",
  "onCutCapture",
  "onPasteCapture",
  "onCompositionEndCapture",
  "onCompositionStartCapture",
  "onCompositionUpdateCapture",
  "onFocusCapture",
  "onBlurCapture",
  "onChangeCapture",
  "onBeforeInputCapture",
  "onInputCapture",
  "onResetCapture",
  "onSubmitCapture",
  "onInvalidCapture",
  "onLoadCapture",
  "onErrorCapture",
  "onKeyDownCapture",
  "onKeyPressCapture",
  "onKeyUpCapture",
  "onAbortCapture",
  "onCanPlayCapture",
  "onCanPlayThroughCapture",
  "onDurationChangeCapture",
  "onEmptiedCapture",
  "onEncryptedCapture",
  "onEndedCapture",
  "onLoadedDataCapture",
  "onLoadedMetadataCapture",
  "onLoadStartCapture",
  "onPauseCapture",
  "onPlayCapture",
  "onPlayingCapture",
  "onProgressCapture",
  "onRateChangeCapture",
  "onSeekedCapture",
  "onSeekingCapture",
  "onStalledCapture",
  "onSuspendCapture",
  "onTimeUpdateCapture",
  "onVolumeChangeCapture",
  "onWaitingCapture",
  "onSelectCapture",
  "onTouchCancelCapture",
  "onTouchEndCapture",
  "onTouchMoveCapture",
  "onTouchStartCapture",
  "onScrollCapture",
  "onWheelCapture",
  "onAnimationEndCapture",
  "onAnimationIteration",
  "onAnimationStartCapture",
  "onTransitionEndCapture",
  "onAuxClick",
  "onAuxClickCapture",
  "onClickCapture",
  "onContextMenuCapture",
  "onDoubleClickCapture",
  "onDragCapture",
  "onDragEndCapture",
  "onDragEnterCapture",
  "onDragExitCapture",
  "onDragLeaveCapture",
  "onDragOverCapture",
  "onDragStartCapture",
  "onDropCapture",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseMoveCapture",
  "onMouseOutCapture",
  "onMouseOverCapture",
  "onMouseUpCapture",
  // Video specific
  "autoPictureInPicture",
  "controlsList",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
var DOM_PROPERTIES_IGNORE_CASE = [
  "charset",
  "allowFullScreen",
  "webkitAllowFullScreen",
  "mozAllowFullScreen",
  "webkitDirectory"
];
var ARIA_PROPERTIES = [
  // See https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes
  // Global attributes
  "aria-atomic",
  "aria-braillelabel",
  "aria-brailleroledescription",
  "aria-busy",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-description",
  "aria-details",
  "aria-disabled",
  "aria-dropeffect",
  "aria-errormessage",
  "aria-flowto",
  "aria-grabbed",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-live",
  "aria-owns",
  "aria-relevant",
  "aria-roledescription",
  // Widget attributes
  "aria-autocomplete",
  "aria-checked",
  "aria-expanded",
  "aria-level",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-placeholder",
  "aria-pressed",
  "aria-readonly",
  "aria-required",
  "aria-selected",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  // Relationship attributes
  "aria-activedescendant",
  "aria-colcount",
  "aria-colindex",
  "aria-colindextext",
  "aria-colspan",
  "aria-posinset",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowindextext",
  "aria-rowspan",
  "aria-setsize"
];
var REACT_ON_PROPS = [
  "onGotPointerCapture",
  "onGotPointerCaptureCapture",
  "onLostPointerCapture",
  "onLostPointerCapture",
  "onLostPointerCaptureCapture",
  "onPointerCancel",
  "onPointerCancelCapture",
  "onPointerDown",
  "onPointerDownCapture",
  "onPointerEnter",
  "onPointerEnterCapture",
  "onPointerLeave",
  "onPointerLeaveCapture",
  "onPointerMove",
  "onPointerMoveCapture",
  "onPointerOut",
  "onPointerOutCapture",
  "onPointerOver",
  "onPointerOverCapture",
  "onPointerUp",
  "onPointerUpCapture"
];
function getDOMPropertyNames(context) {
  const ALL_DOM_PROPERTY_NAMES = DOM_PROPERTY_NAMES_TWO_WORDS.concat(DOM_PROPERTY_NAMES_ONE_WORD);
  {
    return ALL_DOM_PROPERTY_NAMES.concat(REACT_ON_PROPS);
  }
}
function isValidHTMLTagInJSX(childNode) {
  const tagConvention = /^[a-z][^-]*$/;
  if (tagConvention.test(childNode.parent.name.name)) {
    return !childNode.parent.attributes.some(
      (attrNode) => attrNode.type === "JSXAttribute" && attrNode.name.type === "JSXIdentifier" && attrNode.name.name === "is"
      // To learn more about custom web components and `is` attribute,
      // see https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example
    );
  }
  return false;
}
function normalizeAttributeCase(name2) {
  return DOM_PROPERTIES_IGNORE_CASE.find((element) => element.toLowerCase() === name2.toLowerCase()) || name2;
}
function isValidDataAttribute(name2) {
  return !/^data-xml/i.test(name2) && /^data-[^:]*$/.test(name2);
}
function hasUpperCaseCharacter(name2) {
  return name2.toLowerCase() !== name2;
}
function isValidAriaAttribute(name2) {
  return ARIA_PROPERTIES.some((element) => element === name2);
}
function getTagName(node) {
  if (node?.parent?.name) {
    return node.parent.name.name;
  }
  return null;
}
function tagNameHasDot(node) {
  return !!(node.parent?.name && node.parent.name.type === "JSXMemberExpression");
}
function getStandardName(name2, context) {
  if (has(DOM_ATTRIBUTE_NAMES, name2)) {
    return DOM_ATTRIBUTE_NAMES[name2];
  }
  if (has(SVGDOM_ATTRIBUTE_NAMES, name2)) {
    return SVGDOM_ATTRIBUTE_NAMES[name2];
  }
  const names = getDOMPropertyNames();
  return names.find((element) => element.toLowerCase() === name2.toLowerCase());
}
var messages = {
  dataLowercaseRequired: "React does not recognize data-* props with uppercase characters on a DOM element. Found '{{name}}', use '{{lowerCaseName}}' instead",
  invalidPropOnTag: "Invalid property '{{name}}' found on tag '{{tagName}}', but it is only allowed on: {{allowedTags}}",
  unknownProp: "Unknown property '{{name}}' found",
  unknownPropWithStandardName: "Unknown property '{{name}}' found, use '{{standardName}}' instead"
};
var no_unknown_property_default = createRule({
  meta: {
    docs: {
      description: "disallow usage of unknown DOM property"
    },
    fixable: "code",
    messages,
    schema: [{
      type: "object",
      additionalProperties: false,
      properties: {
        ignore: {
          type: "array",
          items: {
            type: "string"
          }
        },
        requireDataLowercase: {
          type: "boolean",
          default: false
        }
      }
    }]
  },
  name: RULE_NAME10,
  create(context) {
    function getIgnoreConfig() {
      return context.options[0]?.ignore || DEFAULTS.ignore;
    }
    function getRequireDataLowercase() {
      return context.options[0] && typeof context.options[0].requireDataLowercase !== "undefined" ? !!context.options[0].requireDataLowercase : DEFAULTS.requireDataLowercase;
    }
    return {
      JSXAttribute(node) {
        const ignoreNames = getIgnoreConfig();
        const actualName = getText(context, node.name);
        if (ignoreNames.indexOf(actualName) >= 0) {
          return;
        }
        const name2 = normalizeAttributeCase(actualName);
        if (tagNameHasDot(node)) {
          return;
        }
        if (isValidDataAttribute(name2)) {
          if (getRequireDataLowercase() && hasUpperCaseCharacter(name2)) {
            report(context, messages.dataLowercaseRequired, "dataLowercaseRequired", {
              node,
              data: {
                name: actualName,
                lowerCaseName: actualName.toLowerCase()
              }
            });
          }
          return;
        }
        if (isValidAriaAttribute(name2)) return;
        const tagName = getTagName(node);
        if (tagName === "fbt" || tagName === "fbs") return;
        if (!isValidHTMLTagInJSX(node)) return;
        const allowedTags = has(ATTRIBUTE_TAGS_MAP, name2) ? ATTRIBUTE_TAGS_MAP[name2] : null;
        if (tagName && allowedTags) {
          if (allowedTags.indexOf(tagName) === -1) {
            report(context, messages.invalidPropOnTag, "invalidPropOnTag", {
              node,
              data: {
                name: actualName,
                allowedTags: allowedTags.join(", "),
                tagName
              }
            });
          }
          return;
        }
        const standardName = getStandardName(name2);
        const hasStandardNameButIsNotUsed = standardName && standardName !== name2;
        const usesStandardName = standardName && standardName === name2;
        if (usesStandardName) {
          return;
        }
        if (hasStandardNameButIsNotUsed) {
          report(context, messages.unknownPropWithStandardName, "unknownPropWithStandardName", {
            node,
            data: {
              name: actualName,
              standardName
            },
            fix(fixer) {
              return fixer.replaceText(node.name, standardName);
            }
          });
          return;
        }
        report(context, messages.unknownProp, "unknownProp", {
          node,
          data: {
            name: actualName
          }
        });
      }
    };
  },
  defaultOptions: []
});
function has(obj, key) {
  return Object.hasOwn(obj, key);
}
function getText(context, node) {
  return context.sourceCode.getText(node);
}
function report(context, message, messageId, data) {
  context.report({
    messageId,
    ...data
  });
}
var RULE_NAME11 = "no-unsafe-iframe-sandbox";
var unsafeCombinations = [
  ["allow-scripts", "allow-same-origin"]
  // ...
];
var no_unsafe_iframe_sandbox_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unsafe iframe 'sandbox' attribute combinations"
    },
    messages: {
      noUnsafeIframeSandbox: "Unsafe 'sandbox' attribute value on 'iframe' component."
    },
    schema: []
  },
  name: RULE_NAME11,
  create(context) {
    const { components, polymorphicPropName } = shared.normalizeSettings(shared.decodeSettings(context.settings));
    return {
      JSXElement(node) {
        const jsxCtx = { getScope: (node2) => context.sourceCode.getScope(node2) };
        const elementType = JSX9__namespace.getElementType(jsxCtx, components, polymorphicPropName)(node.openingElement);
        if (elementType !== "iframe") return;
        const { attributes } = node.openingElement;
        const initialScope = context.sourceCode.getScope(node);
        const maybeSandboxAttribute = JSX9__namespace.findPropInAttributes(attributes, initialScope)("sandbox");
        if (tools.O.isNone(maybeSandboxAttribute)) return;
        const isSafeSandboxValue = !tools.F.pipe(
          JSX9__namespace.getPropValue(maybeSandboxAttribute.value, context.sourceCode.getScope(maybeSandboxAttribute.value)),
          tools.O.flatMapNullable(
            (v) => tsPattern.match(v?.value).with(tsPattern.P.string, tools.F.identity).with({ sandbox: tsPattern.P.string }, ({ sandbox }) => sandbox).otherwise(tools.F.constNull)
          ),
          tools.O.filter(tools.isString),
          tools.O.map((value) => value.split(" ")),
          tools.O.exists(
            (values) => unsafeCombinations.some((combinations) => combinations.every((unsafeValue) => values.includes(unsafeValue)))
          )
        );
        if (isSafeSandboxValue) return;
        context.report({
          messageId: "noUnsafeIframeSandbox",
          node: maybeSandboxAttribute.value
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME12 = "no-unsafe-target-blank";
function isExternalLinkLike(value) {
  return value.startsWith("https://") || /^(?:\w+:|\/\/)/u.test(value);
}
function isSafeRel(value) {
  return value === "noreferrer" || /\bnoreferrer\b/u.test(value);
}
var no_unsafe_target_blank_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: `disallow 'target="_blank"' on an external link without 'rel="noreferrer noopener"'`
    },
    messages: {
      noUnsafeTargetBlank: `Using 'target="_blank"' on an external link without 'rel="noreferrer noopener"' is a security risk.`
    },
    schema: []
  },
  name: RULE_NAME12,
  create(context) {
    const settings = shared.normalizeSettings(shared.decodeSettings(context.settings));
    const polymorphicPropName = settings.polymorphicPropName;
    const components = settings.components;
    const additionalComponents = settings.additionalComponents.filter((c) => c.as === "a");
    function getReportDescriptor(node) {
      const name2 = JSX9__namespace.getElementName(node.openingElement);
      const jsxCtx = { getScope: (node2) => context.sourceCode.getScope(node2) };
      const elementType = JSX9__namespace.getElementType(jsxCtx, components, polymorphicPropName)(node.openingElement);
      if (elementType !== "a" && !additionalComponents.some((c) => c.re.test(name2))) return tools.O.none();
      const { attributes } = node.openingElement;
      const initialScope = context.sourceCode.getScope(node);
      const additionalAttributes = additionalComponents.findLast((c) => c.re.test(name2))?.attributes ?? [];
      const [
        targetPropName,
        targetPropDefaultValue
      ] = shared.findAttrInCustomAttributes("target", additionalAttributes);
      const targetProp = JSX9__namespace.findPropInAttributes(attributes, initialScope)(targetPropName);
      const targetPropValue = tools.O.isNone(targetProp) ? tools.O.fromNullable(targetPropDefaultValue) : tools.F.pipe(
        targetProp,
        tools.O.flatMap((attr) => JSX9__namespace.getPropValue(attr, jsxCtx.getScope(attr))),
        tools.O.flatMapNullable(
          (v) => tsPattern.match(v?.value).with(tsPattern.P.string, tools.F.identity).with({ [targetPropName]: tsPattern.P.string }, (v2) => v2[targetPropName]).otherwise(tools.F.constNull)
        ),
        tools.O.filter(tools.isString)
      );
      if (!tools.O.exists(targetPropValue, (t) => t === "_blank")) return tools.O.none();
      const [
        hrefPropName,
        hrefPropDefaultValue
      ] = shared.findAttrInCustomAttributes("href", additionalAttributes);
      const hrefProp = JSX9__namespace.findPropInAttributes(attributes, initialScope)(hrefPropName);
      const hrefPropValue = tools.O.isNone(hrefProp) ? tools.O.fromNullable(hrefPropDefaultValue) : tools.F.pipe(
        hrefProp,
        tools.O.flatMap((attr) => JSX9__namespace.getPropValue(attr, jsxCtx.getScope(attr))),
        tools.O.flatMapNullable(
          (v) => tsPattern.match(v?.value).with(tsPattern.P.string, tools.F.identity).with(tsPattern.P.shape({ [hrefPropName]: tsPattern.P.string }), (v2) => v2[hrefPropName]).otherwise(tools.F.constNull)
        ),
        tools.O.filter(tools.isString)
      );
      if (!tools.O.exists(hrefPropValue, isExternalLinkLike)) return tools.O.none();
      const [
        relPropName,
        relPropDefaultValue
      ] = shared.findAttrInCustomAttributes("rel", additionalAttributes);
      const relProp = JSX9__namespace.findPropInAttributes(attributes, initialScope)(relPropName);
      const relPropValue = tools.O.isNone(relProp) ? tools.O.fromNullable(relPropDefaultValue) : tools.F.pipe(
        relProp,
        tools.O.flatMap((attr) => JSX9__namespace.getPropValue(attr, jsxCtx.getScope(attr))),
        tools.O.flatMapNullable(
          (v) => tsPattern.match(v?.value).with(tsPattern.P.string, tools.F.identity).with(tsPattern.P.shape({ [relPropName]: tsPattern.P.string }), (v2) => v2[relPropName]).otherwise(tools.F.constNull)
        ),
        tools.O.filter(tools.isString)
      );
      if (tools.O.exists(relPropValue, isSafeRel)) return tools.O.none();
      return tools.O.some({
        messageId: "noUnsafeTargetBlank",
        node
      });
    }
    return {
      JSXElement: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});

// src/index.ts
var DEFAULT_ESLINT_REACT_SETTINGS = {
  additionalComponents: [
    {
      name: "Link",
      as: "a",
      attributes: [
        {
          name: "to",
          as: "href"
        }
      ]
    }
  ],
  skipImportCheck: false
};
var src_default = {
  meta: {
    name,
    version
  },
  rules: {
    "no-children-in-void-dom-elements": no_children_in_void_dom_elements_default,
    "no-dangerously-set-innerhtml": no_dangerously_set_innerhtml_default,
    "no-dangerously-set-innerhtml-with-children": no_dangerously_set_innerhtml_with_children_default,
    "no-find-dom-node": no_find_dom_node_default,
    "no-missing-button-type": no_missing_button_type_default,
    "no-missing-iframe-sandbox": no_missing_iframe_sandbox_default,
    "no-namespace": no_namespace_default,
    "no-render-return-value": no_render_return_value_default,
    "no-script-url": no_script_url_default,
    "no-unknown-property": no_unknown_property_default,
    "no-unsafe-iframe-sandbox": no_unsafe_iframe_sandbox_default,
    "no-unsafe-target-blank": no_unsafe_target_blank_default
  },
  // eslint-disable-next-line perfectionist/sort-objects
  DEFAULT_ESLINT_REACT_SETTINGS
};

module.exports = src_default;
