'use strict';

var JSX7 = require('@eslint-react/jsx');
var tools = require('@eslint-react/tools');
var shared = require('@eslint-react/shared');
var AST11 = require('@eslint-react/ast');
var core = require('@eslint-react/core');
var types = require('@typescript-eslint/types');
var tsPattern = require('ts-pattern');
var VAR = require('@eslint-react/var');
var typeUtils = require('@typescript-eslint/type-utils');
var utils = require('@typescript-eslint/utils');
var astUtils = require('@typescript-eslint/utils/ast-utils');
var ts25 = require('typescript');
var isImmutableType = require('is-immutable-type');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var JSX7__namespace = /*#__PURE__*/_interopNamespace(JSX7);
var AST11__namespace = /*#__PURE__*/_interopNamespace(AST11);
var VAR__namespace = /*#__PURE__*/_interopNamespace(VAR);
var ts25__default = /*#__PURE__*/_interopDefault(ts25);

// package.json
var name = "eslint-plugin-react-x";
var version = "1.16.1";
var createRule = shared.createRuleForPlugin("x");

// src/rules/avoid-shorthand-boolean.ts
var RULE_NAME = "avoid-shorthand-boolean";
var avoid_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using shorthand boolean attributes"
    },
    fixable: "code",
    messages: {
      avoidShorthandBoolean: "Avoid using shorthand boolean attribute '{{propName}}'. Use '{{propName}}={true}' instead."
    },
    schema: []
  },
  name: RULE_NAME,
  create(context) {
    function getReportDescriptor(node) {
      return node.value ? tools.O.none() : tools.O.some({
        messageId: "avoidShorthandBoolean",
        node,
        data: {
          propName: JSX7__namespace.getPropName(node)
        },
        fix: (fixer) => fixer.insertTextAfter(node.name, `={true}`)
      });
    }
    return {
      JSXAttribute: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});

// src/rules/avoid-shorthand-fragment.ts
var RULE_NAME2 = "avoid-shorthand-fragment";
var avoid_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using shorthand fragment syntax"
    },
    messages: {
      avoidShorthandFragment: "Avoid using shorthand fragment syntax. Use 'Fragment' component instead."
    },
    schema: []
  },
  name: RULE_NAME2,
  create(context) {
    return {
      JSXFragment(node) {
        context.report({
          messageId: "avoidShorthandFragment",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME3 = "ensure-forward-ref-using-ref";
var ensure_forward_ref_using_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require a 'ref' parameter to be set when using 'forwardRef'"
    },
    messages: {
      ensureForwardRefUsingRef: "A 'forwardRef' is used with this component but no 'ref' parameter is set."
    },
    schema: []
  },
  name: RULE_NAME3,
  create(context) {
    return {
      CallExpression(node) {
        if (!core.isForwardRefCall(node, context)) return;
        const [component] = node.arguments;
        if (!component || !AST11__namespace.isFunction(component)) return;
        const [_, ref] = component.params;
        if (ref) return;
        context.report({
          messageId: "ensureForwardRefUsingRef",
          node: component
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME4 = "jsx-no-duplicate-props";
var jsx_no_duplicate_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate props"
    },
    messages: {
      jsxNoDuplicateProps: "Duplicate prop '{{name}}'"
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    return {
      JSXOpeningElement(node) {
        const props = [];
        for (const attr of node.attributes) {
          if (attr.type === types.AST_NODE_TYPES.JSXSpreadAttribute) continue;
          const name2 = attr.name.name;
          if (!tools.isString(name2)) continue;
          if (!props.includes(name2)) {
            props.push(name2);
            continue;
          }
          context.report({
            messageId: "jsxNoDuplicateProps",
            node: attr,
            data: { name: name2 }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME5 = "jsx-uses-vars";
var jsx_uses_vars_default = createRule({
  meta: {
    type: "problem",
    docs: {
      // eslint-disable-next-line eslint-plugin/require-meta-docs-description
      description: "a helper rule to mark variables as used"
    },
    messages: {
      jsxUsesVars: ""
    },
    schema: []
  },
  name: RULE_NAME5,
  create(context) {
    function getName5(node) {
      switch (node.type) {
        case types.AST_NODE_TYPES.JSXIdentifier:
          return tools.O.some(node.name);
        case types.AST_NODE_TYPES.JSXMemberExpression:
          return getName5(node.object);
        default:
          return tools.O.none();
      }
    }
    return {
      JSXOpeningElement(node) {
        if (node.name.type === types.AST_NODE_TYPES.JSXIdentifier && /^[a-z]/u.test(node.name.name)) return;
        tools.O.map(getName5(node.name), (name2) => {
          context.sourceCode.markVariableAsUsed(name2, node);
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME6 = "no-access-state-in-setstate";
function getName(node) {
  if (node.type === types.AST_NODE_TYPES.TSAsExpression) {
    return getName(node.expression);
  }
  if (node.type === types.AST_NODE_TYPES.Identifier || node.type === types.AST_NODE_TYPES.PrivateIdentifier) {
    return tools.O.some(node.name);
  }
  if (node.type === types.AST_NODE_TYPES.Literal) {
    return tools.O.some(String(node.value));
  }
  if (node.type === types.AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return tools.O.fromNullable(node.quasis[0]?.value.raw);
  }
  return tools.O.none();
}
var no_access_state_in_setstate_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow accessing 'this.state' within 'setState'"
    },
    messages: {
      noAccessStateInSetstate: "Do not access 'this.state' within 'setState'. Use the update function instead."
    },
    schema: []
  },
  name: RULE_NAME6,
  create(context) {
    if (!context.sourceCode.text.includes("setState")) return {};
    const classStack = [];
    const methodStack = [];
    const setStateStack = [];
    return {
      CallExpression(node) {
        if (!core.isThisSetState(node)) return;
        setStateStack.push([node, false]);
      },
      "CallExpression:exit"(node) {
        if (!core.isThisSetState(node)) return;
        setStateStack.pop();
      },
      ClassDeclaration(node) {
        classStack.push([node, core.isClassComponent(node)]);
      },
      "ClassDeclaration:exit"() {
        classStack.pop();
      },
      ClassExpression(node) {
        classStack.push([node, core.isClassComponent(node)]);
      },
      "ClassExpression:exit"() {
        classStack.pop();
      },
      MemberExpression(node) {
        if (!AST11__namespace.isThisExpression(node.object)) return;
        const [currClass, isComponent] = classStack.at(-1) ?? [];
        if (!currClass || !isComponent) return;
        const [currMethod, isStatic] = methodStack.at(-1) ?? [];
        if (!currMethod || isStatic) return;
        const [setState, hasThisState] = setStateStack.at(-1) ?? [];
        if (!setState || hasThisState) return;
        if (!tools.O.exists(getName(node.property), (name2) => name2 === "state")) return;
        context.report({ messageId: "noAccessStateInSetstate", node });
      },
      MethodDefinition(node) {
        methodStack.push([node, node.static]);
      },
      "MethodDefinition:exit"() {
        methodStack.pop();
      },
      PropertyDefinition(node) {
        methodStack.push([node, node.static]);
      },
      "PropertyDefinition:exit"() {
        methodStack.pop();
      },
      VariableDeclarator(node) {
        const [currClass, isComponent] = classStack.at(-1) ?? [];
        if (!currClass || !isComponent) return;
        const [currMethod, isStatic] = methodStack.at(-1) ?? [];
        if (!currMethod || isStatic) return;
        const [setState, hasThisState] = setStateStack.at(-1) ?? [];
        if (!setState || hasThisState) return;
        if (!(node.init && AST11__namespace.isThisExpression(node.init) && node.id.type === types.AST_NODE_TYPES.ObjectPattern)) return;
        const hasState = node.id.properties.some((prop) => {
          if (prop.type === types.AST_NODE_TYPES.Property && AST11__namespace.isKeyLiteralLike(prop, prop.key)) {
            return tools.O.exists(getName(prop.key), (name2) => name2 === "state");
          }
          return false;
        });
        if (!hasState) return;
        context.report({ messageId: "noAccessStateInSetstate", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME7 = "no-array-index-key";
var reactChildrenMethod = ["forEach", "map"];
var iteratorFunctionIndexParamPosition = /* @__PURE__ */ new Map([
  ["every", 1],
  ["filter", 1],
  ["find", 1],
  ["findIndex", 1],
  ["findLast", 1],
  ["findLastIndex", 1],
  ["flatMap", 1],
  ["forEach", 1],
  ["map", 1],
  ["reduce", 2],
  ["reduceRight", 2],
  ["some", 1]
]);
var isToStringCall = tsPattern.isMatching({
  type: types.AST_NODE_TYPES.CallExpression,
  callee: {
    type: types.AST_NODE_TYPES.MemberExpression,
    property: {
      type: types.AST_NODE_TYPES.Identifier,
      name: "toString"
    }
  }
});
function isReactChildrenMethod(name2) {
  return reactChildrenMethod.some((method) => method === name2);
}
function isUsingReactChildren(node, context) {
  const settings = shared.unsafeReadSettings(context.settings);
  const { callee } = node;
  if (!("property" in callee) || !("object" in callee) || !("name" in callee.property)) {
    return false;
  }
  if (!isReactChildrenMethod(callee.property.name)) return false;
  const initialScope = context.sourceCode.getScope(node);
  if (callee.object.type === types.AST_NODE_TYPES.Identifier && callee.object.name === "Children") return true;
  if (callee.object.type === types.AST_NODE_TYPES.MemberExpression && "name" in callee.object.object) {
    return core.isInitializedFromReact(callee.object.object.name, initialScope, settings);
  }
  return false;
}
function getMapIndexParamName(node, context) {
  const { callee } = node;
  if (callee.type !== types.AST_NODE_TYPES.MemberExpression) return tools.O.none();
  if (callee.property.type !== types.AST_NODE_TYPES.Identifier) return tools.O.none();
  const { name: name2 } = callee.property;
  if (!iteratorFunctionIndexParamPosition.has(name2)) return tools.O.none();
  const callbackArg = node.arguments[isUsingReactChildren(node, context) ? 1 : 0];
  if (!callbackArg) return tools.O.none();
  if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.ArrowFunctionExpression, types.AST_NODE_TYPES.FunctionExpression])(callbackArg)) {
    return tools.O.none();
  }
  const { params } = callbackArg;
  const indexParamPosition = iteratorFunctionIndexParamPosition.get(name2);
  if (tools.isNullable(indexParamPosition)) return tools.O.none();
  if (params.length < indexParamPosition + 1) return tools.O.none();
  const param = params.at(indexParamPosition);
  return param && "name" in param ? tools.O.some(param.name) : tools.O.none();
}
var no_array_index_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using Array index as 'key'"
    },
    messages: {
      noArrayIndexKey: "Do not use Array index as 'key'."
    },
    schema: []
  },
  name: RULE_NAME7,
  create(context) {
    const indexParamNames = [];
    function isArrayIndex(node) {
      return node.type === types.AST_NODE_TYPES.Identifier && indexParamNames.some(tools.O.exists((name2) => name2 === node.name));
    }
    function isCreateOrCloneElementCall(node) {
      return core.isCreateElementCall(node, context) || core.isCloneElementCall(node, context);
    }
    function getReportDescriptor(node) {
      if (isArrayIndex(node)) return [{ messageId: "noArrayIndexKey", node }];
      if (AST11__namespace.isOneOf([types.AST_NODE_TYPES.TemplateLiteral, types.AST_NODE_TYPES.BinaryExpression])(node)) {
        const exps = types.AST_NODE_TYPES.TemplateLiteral === node.type ? node.expressions : AST11__namespace.getIdentifiersFromBinaryExpression(node);
        return exps.reduce((acc, exp) => {
          if (isArrayIndex(exp)) return [...acc, { messageId: "noArrayIndexKey", node: exp }];
          return acc;
        }, []);
      }
      if (isToStringCall(node)) {
        if (!("object" in node.callee && isArrayIndex(node.callee.object))) return [];
        return [{ messageId: "noArrayIndexKey", node: node.callee.object }];
      }
      const isStringCall = tsPattern.isMatching({
        type: types.AST_NODE_TYPES.CallExpression,
        callee: {
          type: types.AST_NODE_TYPES.Identifier,
          name: "String"
        }
      }, node);
      if (isStringCall) {
        const [arg] = node.arguments;
        if (arg && isArrayIndex(arg)) return [{ messageId: "noArrayIndexKey", node: arg }];
      }
      return [];
    }
    return {
      CallExpression(node) {
        indexParamNames.push(getMapIndexParamName(node, context));
        if (node.arguments.length === 0) return;
        if (!isCreateOrCloneElementCall(node)) return;
        const [_, props] = node.arguments;
        if (props?.type !== types.AST_NODE_TYPES.ObjectExpression) return;
        for (const prop of props.properties) {
          if (!tsPattern.isMatching({ key: { name: "key" } }, prop)) continue;
          if (!("value" in prop)) continue;
          const descriptors = getReportDescriptor(prop.value);
          for (const descriptor of descriptors) {
            context.report(descriptor);
          }
        }
      },
      "CallExpression:exit"() {
        indexParamNames.pop();
      },
      JSXAttribute(node) {
        if (node.name.name !== "key") return;
        if (indexParamNames.length === 0) return;
        const { value } = node;
        if (value?.type !== types.AST_NODE_TYPES.JSXExpressionContainer) return;
        const descriptors = getReportDescriptor(value.expression);
        for (const descriptor of descriptors) {
          context.report(descriptor);
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME8 = "no-children-count";
var no_children_count_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.count'"
    },
    messages: {
      noChildrenCount: "Using 'Children.count' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME8,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenCount(node, context)) {
          context.report({
            messageId: "noChildrenCount",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME9 = "no-children-for-each";
var no_children_for_each_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.forEach'"
    },
    messages: {
      noChildrenForEach: "Using 'Children.forEach' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME9,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenForEach(node, context)) {
          context.report({
            messageId: "noChildrenForEach",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME10 = "no-children-map";
var no_children_map_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.map'"
    },
    messages: {
      noChildrenMap: "Using 'Children.map' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME10,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenMap(node, context)) {
          context.report({
            messageId: "noChildrenMap",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME11 = "no-children-only";
var no_children_only_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.only'"
    },
    messages: {
      noChildrenOnly: "Using 'Children.only' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME11,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenOnly(node, context)) {
          context.report({
            messageId: "noChildrenOnly",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME12 = "no-children-prop";
var no_children_prop_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow passing 'children' as props"
    },
    messages: {
      noChildrenProp: "Do not pass 'children' as props."
    },
    schema: []
  },
  name: RULE_NAME12,
  create(context) {
    return {
      JSXElement(node) {
        const initialScope = context.sourceCode.getScope(node);
        const prop = JSX7__namespace.getProp(node.openingElement.attributes, "children", initialScope);
        const reportDescriptor = tools.O.map(prop, (prop2) => ({ messageId: "noChildrenProp", node: prop2 }));
        tools.O.map(reportDescriptor, context.report);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME13 = "no-children-to-array";
var no_children_to_array_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.toArray'"
    },
    messages: {
      noChildrenToArray: "Using 'Children.toArray' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME13,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenToArray(node, context)) {
          context.report({
            messageId: "noChildrenToArray",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME14 = "no-class-component";
var isComponentDidCatch = tsPattern.isMatching({
  key: {
    type: types.AST_NODE_TYPES.Identifier,
    name: "componentDidCatch"
  },
  type: tsPattern.P.union(types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition),
  static: false
});
var isGetDerivedStateFromError = tsPattern.isMatching({
  key: {
    type: types.AST_NODE_TYPES.Identifier,
    name: "getDerivedStateFromError"
  },
  type: tsPattern.P.union(types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition),
  static: true
});
var no_class_component_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using class components"
    },
    messages: {
      noClassComponent: "Do not use class components. Use function components instead."
    },
    schema: []
  },
  name: RULE_NAME14,
  create(context) {
    if (!context.sourceCode.text.includes("Component")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { name: name2, node: component } of components.values()) {
          if (component.body.body.some((m) => isComponentDidCatch(m) || isGetDerivedStateFromError(m))) continue;
          context.report({
            messageId: "noClassComponent",
            node: component,
            data: {
              // eslint-disable-next-line eslint-plugin/no-unused-placeholders
              name: tools.O.getOrElse(tools.F.constant("anonymous"))(name2)
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME15 = "no-clone-element";
var no_clone_element_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'cloneElement'"
    },
    messages: {
      noCloneElement: "Using 'cloneElement' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME15,
  create(context) {
    return {
      CallExpression(node) {
        if (!core.isCloneElementCall(node, context)) return;
        context.report({
          messageId: "noCloneElement",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME16 = "no-comment-textnodes";
var no_comment_textnodes_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow comments from being inserted as text nodes"
    },
    messages: {
      noCommentTextnodes: "Possible misused comment in text node. Comments inside children section of tag should be placed inside braces."
    },
    schema: []
  },
  name: RULE_NAME16,
  create(context) {
    function hasCommentLike(node) {
      if (AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXAttribute, types.AST_NODE_TYPES.JSXExpressionContainer])(node.parent)) return false;
      const rawValue = context.sourceCode.getText(node);
      return /^\s*\/(?:\/|\*)/mu.test(rawValue);
    }
    const getReportDescriptor = (node) => {
      if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXElement, types.AST_NODE_TYPES.JSXFragment])(node.parent)) return tools.O.none();
      if (!hasCommentLike(node)) return tools.O.none();
      if (!node.parent.type.includes("JSX")) return tools.O.none();
      return tools.O.some({
        messageId: "noCommentTextnodes",
        node
      });
    };
    const ruleFunction = tools.F.flow(getReportDescriptor, tools.O.map(context.report), tools.F.constVoid);
    return {
      JSXText: ruleFunction,
      Literal: ruleFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME17 = "no-complex-conditional-rendering";
var no_complex_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow complex conditional rendering"
    },
    messages: {
      noComplexConditionalRendering: "Avoid complex conditional rendering. Extract the logic into separate elements or components."
    },
    schema: []
  },
  name: RULE_NAME17,
  create(context) {
    function getReportDescriptor(node) {
      const jsxExpContainer = node.parent?.parent;
      if (!AST11__namespace.is(types.AST_NODE_TYPES.JSXExpressionContainer)(jsxExpContainer)) return tools.O.none();
      if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXElement, types.AST_NODE_TYPES.JSXFragment])(jsxExpContainer.parent)) {
        return tools.O.none();
      }
      if (!jsxExpContainer.parent.children.includes(jsxExpContainer)) return tools.O.none();
      return tools.O.some({ messageId: "noComplexConditionalRendering", node: jsxExpContainer });
    }
    const ruleFunction = tools.F.flow(getReportDescriptor, tools.O.map(context.report), tools.F.constVoid);
    return {
      "JSXExpressionContainer > ConditionalExpression > ConditionalExpression": ruleFunction,
      "JSXExpressionContainer > ConditionalExpression > LogicalExpression": ruleFunction,
      "JSXExpressionContainer > LogicalExpression > ConditionalExpression": ruleFunction,
      "JSXExpressionContainer > LogicalExpression[operator='&&'] > LogicalExpression[operator='||']": ruleFunction,
      "JSXExpressionContainer > LogicalExpression[operator='||'] > LogicalExpression[operator='&&']": ruleFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME18 = "no-component-will-mount";
function isComponentWillMount(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillMount";
}
var no_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'componentWillMount'"
    },
    messages: {
      noComponentWillMount: "[Deprecated] Use 'UNSAFE_componentWillMount' instead."
    },
    schema: []
  },
  name: RULE_NAME18,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillMount")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillMount(member)) {
              context.report({
                messageId: "noComponentWillMount",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME19 = "no-component-will-receive-props";
function isComponentWillUpdate(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillReceiveProps";
}
var no_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'componentWillReceiveProps'"
    },
    messages: {
      noComponentWillReceiveProps: "[Deprecated] Use 'UNSAFE_componentWillReceiveProps' instead."
    },
    schema: []
  },
  name: RULE_NAME19,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillReceiveProps")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillUpdate(member)) {
              context.report({
                messageId: "noComponentWillReceiveProps",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME20 = "no-component-will-update";
function isComponentWillUpdate2(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
var no_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'componentWillReceiveProps'"
    },
    messages: {
      noComponentWillUpdate: "[Deprecated] Use 'UNSAFE_componentWillUpdate' instead."
    },
    schema: []
  },
  name: RULE_NAME20,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillUpdate2(member)) {
              context.report({
                messageId: "noComponentWillUpdate",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME21 = "no-create-ref";
var no_create_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'createRef' in function components"
    },
    messages: {
      noCreateRef: "[Deprecated] Use 'useRef' instead."
    },
    schema: []
  },
  name: RULE_NAME21,
  create(context) {
    return {
      CallExpression(node) {
        if (!core.isCreateRefCall(node, context)) return;
        if (tools.O.isSome(AST11__namespace.traverseUp(node, core.isClassComponent))) return;
        context.report({ messageId: "noCreateRef", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME22 = "no-default-props";
var no_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'defaultProps' property in components"
    },
    messages: {
      noDefaultProps: "[Deprecated] Use ES6 default parameters instead."
    },
    schema: []
  },
  name: RULE_NAME22,
  create(context) {
    if (!context.sourceCode.text.includes("defaultProps")) return {};
    return {
      AssignmentExpression(node) {
        if (node.operator !== "=" || node.left.type !== types.AST_NODE_TYPES.MemberExpression) return;
        const { object, property } = node.left;
        if (object.type !== types.AST_NODE_TYPES.Identifier) return;
        if (property.type !== types.AST_NODE_TYPES.Identifier || property.name !== "defaultProps") return;
        if (!core.isComponentName(object.name)) return;
        const isComponent = tools.F.pipe(
          VAR__namespace.findVariable(object.name, context.sourceCode.getScope(node)),
          tools.O.flatMap(VAR__namespace.getVariableNode(0)),
          tools.O.exists((n) => AST11__namespace.isFunction(n) || core.isClassComponent(n))
        );
        if (!isComponent) return;
        context.report({ messageId: "noDefaultProps", node: property });
      },
      PropertyDefinition(node) {
        if (!core.isClassComponent(node.parent.parent)) return;
        if (!node.static || node.key.type !== types.AST_NODE_TYPES.Identifier || node.key.name !== "defaultProps") return;
        context.report({ messageId: "noDefaultProps", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME23 = "no-direct-mutation-state";
function getName2(node) {
  if (node.type === types.AST_NODE_TYPES.TSAsExpression) {
    return getName2(node.expression);
  }
  if (node.type === types.AST_NODE_TYPES.Identifier || node.type === types.AST_NODE_TYPES.PrivateIdentifier) {
    return tools.O.some(node.name);
  }
  if (node.type === types.AST_NODE_TYPES.Literal) {
    return tools.O.some(String(node.value));
  }
  if (node.type === types.AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return tools.O.fromNullable(node.quasis[0]?.value.raw);
  }
  return tools.O.none();
}
function isAssignmentToThisState(node) {
  const { left } = node;
  return left.type === types.AST_NODE_TYPES.MemberExpression && AST11__namespace.isThisExpression(left.object) && tools.O.exists(getName2(left.property), (name2) => name2 === "state");
}
function isConstructorFunction(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.FunctionDeclaration, types.AST_NODE_TYPES.FunctionExpression])(node) && AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node.parent) && node.parent.key.type === types.AST_NODE_TYPES.Identifier && node.parent.key.name === "constructor";
}
var no_direct_mutation_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow direct mutation of state"
    },
    messages: {
      noDirectMutationState: "Do not mutate state directly. Use 'setState()' instead."
    },
    schema: []
  },
  name: RULE_NAME23,
  create(context) {
    function getReportDescriptor(node) {
      if (!isAssignmentToThisState(node)) return tools.O.none();
      const maybeParentClass = AST11__namespace.traverseUpGuard(
        node,
        AST11__namespace.isOneOf([types.AST_NODE_TYPES.ClassDeclaration, types.AST_NODE_TYPES.ClassExpression])
      );
      if (tools.O.isNone(maybeParentClass)) return tools.O.none();
      const parentClass = maybeParentClass.value;
      if (!core.isClassComponent(parentClass)) return tools.O.none();
      const maybeParentConstructor = AST11__namespace.traverseUpGuard(node, isConstructorFunction);
      if (tools.O.exists(maybeParentConstructor, (n) => context.sourceCode.getScope(node).block === n)) return tools.O.none();
      return tools.O.some({
        messageId: "noDirectMutationState",
        node
      });
    }
    return {
      AssignmentExpression: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME24 = "no-duplicate-key";
var no_duplicate_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate keys when rendering list"
    },
    messages: {
      noDuplicateKey: "A key must be unique. '{{value}}' is duplicated."
    },
    schema: []
  },
  name: RULE_NAME24,
  create(context) {
    const isWithinChildrenToArrayRef = tools.MutRef.make(false);
    function isKeyEqual(a, b) {
      return VAR__namespace.isNodeValueEqual(a, b, [context.sourceCode.getScope(a), context.sourceCode.getScope(b)]);
    }
    function checkIteratorElement(node) {
      if (node.type !== types.AST_NODE_TYPES.JSXElement) return tools.O.none();
      const initialScope = context.sourceCode.getScope(node);
      return tools.F.pipe(
        JSX7__namespace.findPropInAttributes(node.openingElement.attributes, initialScope)("key"),
        tools.O.flatMap((k) => "value" in k ? tools.O.fromNullable(k.value) : tools.O.none()),
        tools.O.flatMap((v) => {
          return isKeyEqual(v, v) ? tools.O.some({
            messageId: "noDuplicateKey",
            node: v,
            data: {
              value: context.sourceCode.getText(v)
            }
          }) : tools.O.none();
        })
      );
    }
    function checkExpression(node) {
      switch (node.type) {
        case types.AST_NODE_TYPES.ConditionalExpression:
          if (!("consequent" in node)) return tools.O.none();
          return tools.F.pipe(
            checkIteratorElement(node.consequent),
            tools.O.orElse(() => checkIteratorElement(node.alternate))
          );
        case types.AST_NODE_TYPES.JSXElement:
        case types.AST_NODE_TYPES.JSXFragment:
          return checkIteratorElement(node);
        case types.AST_NODE_TYPES.LogicalExpression:
          if (!("left" in node)) return tools.O.none();
          return tools.F.pipe(
            checkIteratorElement(node.left),
            tools.O.orElse(() => checkIteratorElement(node.right))
          );
        default:
          return tools.O.none();
      }
    }
    function checkBlockStatement(node) {
      return AST11__namespace.getNestedReturnStatements(node).reduce((acc, statement) => {
        if (!statement.argument) return acc;
        const maybeDescriptor = checkIteratorElement(statement.argument);
        if (tools.O.isNone(maybeDescriptor)) return acc;
        const descriptor = maybeDescriptor.value;
        return [...acc, descriptor];
      }, []);
    }
    const seen = /* @__PURE__ */ new WeakSet();
    return {
      "ArrayExpression, JSXElement > JSXElement"(node) {
        if (tools.MutRef.get(isWithinChildrenToArrayRef)) return;
        const elements = tsPattern.match(node).with({ type: types.AST_NODE_TYPES.ArrayExpression }, ({ elements: elements2 }) => elements2).with({ type: types.AST_NODE_TYPES.JSXElement }, ({ parent }) => "children" in parent ? parent.children : []).otherwise(() => []).filter(AST11__namespace.is(types.AST_NODE_TYPES.JSXElement)).filter((element) => !seen.has(element));
        const keys = elements.reduce(
          (acc, element) => {
            const attr = element.openingElement.attributes.findLast((attr2) => {
              if (attr2.type !== types.AST_NODE_TYPES.JSXAttribute) return false;
              return attr2.name.name === "key";
            });
            if (!attr || !("value" in attr) || attr.value === null) return acc;
            const { value } = attr;
            if (acc.length === 0) return [[element, attr, value]];
            if (acc.some(([_, _1, v]) => isKeyEqual(v, value))) {
              return [...acc, [element, attr, value]];
            }
            return acc;
          },
          []
        );
        if (keys.length < 2) return;
        for (const [element, attr, value] of keys) {
          seen.add(element);
          context.report({
            messageId: "noDuplicateKey",
            node: attr,
            data: {
              value: context.sourceCode.getText(value)
            }
          });
        }
      },
      CallExpression(node) {
        if (core.isChildrenToArrayCall(node, context)) tools.MutRef.set(isWithinChildrenToArrayRef, true);
        const isMapCall = AST11__namespace.isMapCallLoose(node);
        const isArrayFromCall = tsPattern.isMatching({
          type: types.AST_NODE_TYPES.CallExpression,
          callee: {
            type: types.AST_NODE_TYPES.MemberExpression,
            property: {
              name: "from"
            }
          }
        }, node);
        if (!isMapCall && !isArrayFromCall) return;
        if (tools.MutRef.get(isWithinChildrenToArrayRef)) return;
        const fn = node.arguments[isMapCall ? 0 : 1];
        if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.ArrowFunctionExpression, types.AST_NODE_TYPES.FunctionExpression])(fn)) return;
        if (fn.body.type === types.AST_NODE_TYPES.BlockStatement) {
          for (const descriptor of checkBlockStatement(fn.body)) {
            context.report(descriptor);
          }
          return;
        }
        tools.O.map(checkExpression(fn.body), context.report);
      },
      "CallExpression:exit"(node) {
        if (core.isChildrenToArrayCall(node, context)) tools.MutRef.set(isWithinChildrenToArrayRef, false);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME25 = "no-implicit-key";
var no_implicit_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow implicit 'key' props"
    },
    messages: {
      noImplicitKey: "Do not use implicit 'key' props."
    },
    schema: []
  },
  name: RULE_NAME25,
  create(context) {
    function getReportDescriptor(node) {
      const initialScope = context.sourceCode.getScope(node);
      const keyPropFound = JSX7__namespace.findPropInAttributes(node.attributes, initialScope)("key");
      const keyPropOnElement = node.attributes.some(
        (n) => AST11__namespace.is(types.AST_NODE_TYPES.JSXAttribute)(n) && n.name.name === "key"
      );
      if (tools.O.isSome(keyPropFound) && !keyPropOnElement) {
        return tools.O.some({ messageId: "noImplicitKey", node: keyPropFound.value });
      }
      return tools.O.none();
    }
    return {
      JSXOpeningElement: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var require_constants = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name2, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name2, index, value);
      t[name2] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});
var require_parse = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse();
    var valid = (version2, options) => {
      const v = parse(version2, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse();
    var clean = (version2, options) => {
      const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  }
});
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  }
});
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match4 = null;
      if (!options.rtl) {
        match4 = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match4 || match4.index + match4[0].length !== version2.length)) {
          if (!match4 || next.index + next[0].length !== match4.index + match4[0].length) {
            match4 = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match4 === null) {
        return null;
      }
      const major = match4[2];
      const minor = match4[3] || "0";
      const patch = match4[4] || "0";
      const prerelease = options.includePrerelease && match4[5] ? `-${match4[5]}` : "";
      const build = options.includePrerelease && match4[6] ? `+${match4[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});
var require_lrucache = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/lrucache.js"(exports, module) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js"(exports, module) {
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module.exports = satisfies;
  }
});
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module.exports = gtr;
  }
});
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module.exports = ltr;
  }
});
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.6.2/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});
function isFlagSet(allFlags, flag) {
  return (allFlags & flag) !== 0;
}
function isFlagSetOnObject(obj, flag) {
  return isFlagSet(obj.flags, flag);
}
var isTypeFlagSet = isFlagSetOnObject;
ts25__default.default.versionMajorMinor.split(".").map((raw) => Number.parseInt(raw, 10));
ts25__default.default.TypeFlags.Intrinsic ?? ts25__default.default.TypeFlags.Any | ts25__default.default.TypeFlags.Unknown | ts25__default.default.TypeFlags.String | ts25__default.default.TypeFlags.Number | ts25__default.default.TypeFlags.BigInt | ts25__default.default.TypeFlags.Boolean | ts25__default.default.TypeFlags.BooleanLiteral | ts25__default.default.TypeFlags.ESSymbol | ts25__default.default.TypeFlags.Void | ts25__default.default.TypeFlags.Undefined | ts25__default.default.TypeFlags.Null | ts25__default.default.TypeFlags.Never | ts25__default.default.TypeFlags.NonPrimitive;
function isUnionType(type) {
  return isTypeFlagSet(type, ts25__default.default.TypeFlags.Union);
}
function isBooleanLiteralType(type) {
  return isTypeFlagSet(type, ts25__default.default.TypeFlags.BooleanLiteral);
}
function isFalseLiteralType(type) {
  return isBooleanLiteralType(type) && type.intrinsicName === "false";
}
function isTrueLiteralType(type) {
  return isBooleanLiteralType(type) && type.intrinsicName === "true";
}
__toESM(require_semver2());
function unionTypeParts(type) {
  return isUnionType(type) ? type.types : [type];
}
var RULE_NAME26 = "no-leaked-conditional-rendering";
var allowedVariants = [
  "any",
  "boolean",
  "nullish",
  "object",
  "string",
  "falsy string",
  "falsy boolean",
  "truthy bigint",
  "truthy boolean",
  "truthy number",
  "truthy string"
];
var tsHelpers = {
  isAnyType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.TypeParameter | ts25__default.default.TypeFlags.Any),
  isBigIntType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.BigIntLike),
  isBooleanType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.BooleanLike),
  isEnumType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.EnumLike),
  isFalsyBigIntType: (type) => type.isLiteral() && tsPattern.isMatching({ value: { base10Value: "0" } }, type),
  isFalsyNumberType: (type) => type.isNumberLiteral() && type.value === 0,
  isFalsyStringType: (type) => type.isStringLiteral() && type.value === "",
  isNeverType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.Never),
  isNullishType: (type) => isTypeFlagSet(
    type,
    ts25__default.default.TypeFlags.Null | ts25__default.default.TypeFlags.Undefined | ts25__default.default.TypeFlags.VoidLike
  ),
  isNumberType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.NumberLike),
  isObjectType: (type) => !isTypeFlagSet(
    type,
    ts25__default.default.TypeFlags.Null | ts25__default.default.TypeFlags.Undefined | ts25__default.default.TypeFlags.VoidLike | ts25__default.default.TypeFlags.BooleanLike | ts25__default.default.TypeFlags.StringLike | ts25__default.default.TypeFlags.NumberLike | ts25__default.default.TypeFlags.BigIntLike | ts25__default.default.TypeFlags.TypeParameter | ts25__default.default.TypeFlags.Any | ts25__default.default.TypeFlags.Unknown | ts25__default.default.TypeFlags.Never
  ),
  isStringType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.StringLike),
  isTruthyBigIntType: (type) => type.isLiteral() && tsPattern.isMatching({ value: { base10Value: tsPattern.P.not("0") } }, type),
  isTruthyNumberType: (type) => type.isNumberLiteral() && type.value !== 0,
  isTruthyStringType: (type) => type.isStringLiteral() && type.value !== "",
  isUnknownType: (type) => isTypeFlagSet(type, ts25__default.default.TypeFlags.Unknown)
};
function inspectVariantTypes(types) {
  const variantTypes = /* @__PURE__ */ new Set();
  if (types.some(tsHelpers.isUnknownType)) {
    variantTypes.add("unknown");
    return variantTypes;
  }
  if (types.some(tsHelpers.isNullishType)) {
    variantTypes.add("nullish");
  }
  const booleans = types.filter(tsHelpers.isBooleanType);
  switch (true) {
    case (booleans.length === 1 && !!booleans[0]): {
      const [first] = booleans;
      const evaluated = tools.F.pipe(
        tsPattern.match(first).when(isTrueLiteralType, () => tools.O.some("truthy boolean")).when(isFalseLiteralType, () => tools.O.some("falsy boolean")).otherwise(tools.O.none)
      );
      tools.O.map(evaluated, (v) => variantTypes.add(v));
      break;
    }
    case booleans.length === 2: {
      variantTypes.add("boolean");
      break;
    }
  }
  const strings = types.filter(tsHelpers.isStringType);
  if (strings.length > 0) {
    const evaluated = tsPattern.match(strings).when((types2) => types2.every(tsHelpers.isTruthyStringType), tools.F.constant("truthy string")).when((types2) => types2.every(tsHelpers.isFalsyStringType), tools.F.constant("falsy string")).otherwise(tools.F.constant("string"));
    variantTypes.add(evaluated);
  }
  const bigints = types.filter(tsHelpers.isBigIntType);
  if (bigints.length > 0) {
    const evaluated = tsPattern.match(bigints).when((types2) => types2.every(tsHelpers.isTruthyBigIntType), tools.F.constant("truthy bigint")).when((types2) => types2.every(tsHelpers.isFalsyBigIntType), tools.F.constant("falsy bigint")).otherwise(tools.F.constant("bigint"));
    variantTypes.add(evaluated);
  }
  const numbers = types.filter(tsHelpers.isNumberType);
  if (numbers.length > 0) {
    const evaluated = tsPattern.match(numbers).when((types2) => types2.every(tsHelpers.isTruthyNumberType), tools.F.constant("truthy number")).when((types2) => types2.every(tsHelpers.isFalsyNumberType), tools.F.constant("falsy number")).otherwise(tools.F.constant("number"));
    variantTypes.add(evaluated);
  }
  if (types.some(tsHelpers.isEnumType)) {
    variantTypes.add("enum");
  }
  if (types.some(tsHelpers.isObjectType)) {
    variantTypes.add("object");
  }
  if (types.some(tsHelpers.isAnyType)) {
    variantTypes.add("any");
  }
  if (types.some(tsHelpers.isNeverType)) {
    variantTypes.add("never");
  }
  return variantTypes;
}
function isInitExpression(node) {
  return node.type !== types.AST_NODE_TYPES.VariableDeclaration;
}
function getVariableInitExpression(at) {
  return (variable) => {
    return tools.F.pipe(
      tools.O.some(variable),
      tools.O.flatMapNullable((v) => v.defs.at(at)),
      tools.O.flatMap(
        (d) => "init" in d.node ? tools.O.fromNullable(d.node.init) : tools.O.none()
      ),
      tools.O.filter(isInitExpression)
    );
  };
}
var no_leaked_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow problematic leaked values from being rendered"
    },
    messages: {
      noLeakedConditionalRendering: "Potential leaked value {{value}} that might cause unintentionally rendered values or rendering crashes."
    },
    schema: []
  },
  name: RULE_NAME26,
  create(context) {
    if (!context.sourceCode.text.includes("&&") && !context.sourceCode.text.includes("?")) return {};
    const services = utils.ESLintUtils.getParserServices(context, false);
    function getReportDescriptor(node) {
      return tsPattern.match(node).when(AST11__namespace.isJSX, tools.O.none).with({ type: types.AST_NODE_TYPES.LogicalExpression, operator: "&&" }, ({ left, right }) => {
        const isLeftUnaryNot = tsPattern.isMatching({ type: types.AST_NODE_TYPES.UnaryExpression, operator: "!" }, left);
        if (isLeftUnaryNot) return getReportDescriptor(right);
        const initialScope = context.sourceCode.getScope(left);
        const isLeftNan = tsPattern.isMatching({ type: types.AST_NODE_TYPES.Identifier, name: "NaN" }, left) || astUtils.getStaticValue(left, initialScope)?.value === "NaN";
        if (isLeftNan) {
          return tools.O.some({
            messageId: "noLeakedConditionalRendering",
            node: left,
            data: { value: context.sourceCode.getText(left) }
          });
        }
        const leftType = typeUtils.getConstrainedTypeAtLocation(services, left);
        const leftTypeVariants = inspectVariantTypes(unionTypeParts(leftType));
        const isLeftValid = Array.from(leftTypeVariants.values()).every((type) => allowedVariants.some((allowed) => allowed === type));
        if (isLeftValid) return getReportDescriptor(right);
        return tools.O.some({
          messageId: "noLeakedConditionalRendering",
          node: left,
          data: { value: context.sourceCode.getText(left) }
        });
      }).with({ type: types.AST_NODE_TYPES.ConditionalExpression }, ({ alternate, consequent }) => {
        return tools.O.orElse(getReportDescriptor(consequent), () => getReportDescriptor(alternate));
      }).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => {
        return tools.F.pipe(
          VAR__namespace.findVariable(n.name, context.sourceCode.getScope(n)),
          tools.O.flatMap(getVariableInitExpression(0)),
          tools.O.flatMap(getReportDescriptor)
        );
      }).otherwise(tools.O.none);
    }
    const ruleFunction = tools.F.flow(getReportDescriptor, tools.O.map(context.report), tools.F.constVoid);
    return {
      "JSXExpressionContainer > ConditionalExpression": ruleFunction,
      "JSXExpressionContainer > LogicalExpression": ruleFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME27 = "no-missing-component-display-name";
var no_missing_component_display_name_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require 'displayName' for 'memo' and 'forwardRef' components"
    },
    messages: {
      noMissingComponentDisplayName: "Add missing 'displayName' for component."
    },
    schema: []
  },
  name: RULE_NAME27,
  create(context) {
    if (!context.sourceCode.text.includes("memo") && !context.sourceCode.text.includes("forwardRef")) return {};
    const { ctx, listeners } = core.useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: node2, displayName, flag } of components.values()) {
          const isMemoOrForwardRef = Boolean(flag & core.ERFunctionComponentFlag.ForwardRef) || Boolean(flag & core.ERFunctionComponentFlag.Memo);
          if (tools.O.isSome(AST11__namespace.getFunctionIdentifier(node2))) continue;
          if (!isMemoOrForwardRef) continue;
          if (tools.O.isNone(displayName)) {
            context.report({
              messageId: "noMissingComponentDisplayName",
              node: node2
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME28 = "no-missing-key";
var no_missing_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require 'key' when rendering list"
    },
    messages: {
      noMissingKey: "Missing 'key' for element when rendering list.",
      noMissingKeyWithFragment: "Use fragment component instead of '<>' because it does not support `key`."
    },
    schema: []
  },
  name: RULE_NAME28,
  create(context) {
    const isWithinChildrenToArrayRef = tools.MutRef.make(false);
    function checkIteratorElement(node) {
      switch (node.type) {
        case types.AST_NODE_TYPES.JSXElement: {
          const initialScope = context.sourceCode.getScope(node);
          if (!JSX7__namespace.hasProp(node.openingElement.attributes, "key", initialScope)) {
            return tools.O.some({
              messageId: "noMissingKey",
              node
            });
          }
          return tools.O.none();
        }
        case types.AST_NODE_TYPES.JSXFragment: {
          return tools.O.some({
            messageId: "noMissingKeyWithFragment",
            node
          });
        }
        default:
          return tools.O.none();
      }
    }
    function checkExpression(node) {
      switch (node.type) {
        case types.AST_NODE_TYPES.ConditionalExpression:
          if (!("consequent" in node)) return tools.O.none();
          return tools.O.orElse(checkIteratorElement(node.consequent), () => checkIteratorElement(node.alternate));
        case types.AST_NODE_TYPES.JSXElement:
        case types.AST_NODE_TYPES.JSXFragment:
          return checkIteratorElement(node);
        case types.AST_NODE_TYPES.LogicalExpression:
          if (!("left" in node)) return tools.O.none();
          return tools.O.orElse(checkIteratorElement(node.left), () => checkIteratorElement(node.right));
        default:
          return tools.O.none();
      }
    }
    function checkBlockStatement(node) {
      return AST11__namespace.getNestedReturnStatements(node).reduce((acc, statement) => {
        if (!statement.argument) return acc;
        const maybeDescriptor = checkIteratorElement(statement.argument);
        if (tools.O.isNone(maybeDescriptor)) return acc;
        const descriptor = maybeDescriptor.value;
        return [...acc, descriptor];
      }, []);
    }
    return {
      ArrayExpression(node) {
        if (tools.MutRef.get(isWithinChildrenToArrayRef)) return;
        const elements = node.elements.filter(AST11__namespace.is(types.AST_NODE_TYPES.JSXElement));
        if (elements.length === 0) return;
        const initialScope = context.sourceCode.getScope(node);
        for (const element of elements) {
          if (!JSX7__namespace.hasProp(element.openingElement.attributes, "key", initialScope)) {
            context.report({
              messageId: "noMissingKey",
              node: element
            });
          }
        }
      },
      CallExpression(node) {
        if (core.isChildrenToArrayCall(node, context)) tools.MutRef.set(isWithinChildrenToArrayRef, true);
        const isMapCall = AST11__namespace.isMapCallLoose(node);
        const isArrayFromCall = tsPattern.isMatching({
          type: types.AST_NODE_TYPES.CallExpression,
          callee: {
            type: types.AST_NODE_TYPES.MemberExpression,
            property: {
              name: "from"
            }
          }
        }, node);
        if (!isMapCall && !isArrayFromCall) return;
        if (tools.MutRef.get(isWithinChildrenToArrayRef)) return;
        const fn = node.arguments[isMapCall ? 0 : 1];
        if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.ArrowFunctionExpression, types.AST_NODE_TYPES.FunctionExpression])(fn)) return;
        if (fn.body.type === types.AST_NODE_TYPES.BlockStatement) {
          for (const descriptor of checkBlockStatement(fn.body)) {
            context.report(descriptor);
          }
          return;
        }
        tools.O.map(checkExpression(fn.body), context.report);
      },
      "CallExpression:exit"(node) {
        if (core.isChildrenToArrayCall(node, context)) tools.MutRef.set(isWithinChildrenToArrayRef, false);
      },
      JSXFragment(node) {
        if (tools.MutRef.get(isWithinChildrenToArrayRef)) return;
        if (node.parent.type === types.AST_NODE_TYPES.ArrayExpression) {
          context.report({
            messageId: "noMissingKeyWithFragment",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME29 = "no-nested-components";
var no_nested_components_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using unstable nested components"
    },
    messages: {
      nestedComponent: "Do not nest components inside other components. Move it to the top level.",
      nestedComponentInProps: "Do not nest components inside props. Move it to the top level or pass it as a prop."
    },
    schema: []
  },
  name: RULE_NAME29,
  create(context) {
    const hint = core.ERComponentHint.SkipMapCallback | core.ERComponentHint.SkipNullLiteral | core.ERComponentHint.SkipUndefinedLiteral | core.ERComponentHint.SkipBooleanLiteral | core.ERComponentHint.SkipStringLiteral | core.ERComponentHint.SkipNumberLiteral | core.ERComponentHint.StrictLogical | core.ERComponentHint.StrictConditional;
    const collector = core.useComponentCollector(context, hint);
    const collectorLegacy = core.useComponentCollectorLegacy();
    return {
      ...collector.listeners,
      ...collectorLegacy.listeners,
      "Program:exit"(node) {
        const functionComponents = Array.from(collector.ctx.getAllComponents(node).values());
        const classComponents = Array.from(collectorLegacy.ctx.getAllComponents(node).values());
        const isFunctionComponent = (node2) => {
          return AST11__namespace.isFunction(node2) && functionComponents.some((component) => component.node === node2);
        };
        const isClassComponent11 = (node2) => {
          return AST11__namespace.isClass(node2) && classComponents.some((component) => component.node === node2);
        };
        for (const { name: componentName, node: component } of functionComponents) {
          if (core.isDirectValueOfRenderPropertyLoose(component)) continue;
          if (tools.O.isNone(componentName)) continue;
          const name2 = componentName.value;
          const isInsideProperty = component.parent.type === types.AST_NODE_TYPES.Property;
          const isInsideJSXPropValue = component.parent.type === types.AST_NODE_TYPES.JSXAttribute || tools.O.isSome(JSX7__namespace.traverseUpProp(node, (n) => n.value?.type === types.AST_NODE_TYPES.JSXExpressionContainer));
          if (isInsideJSXPropValue) {
            if (!core.isDeclaredInRenderPropLoose(component)) {
              context.report({
                messageId: "nestedComponentInProps",
                node: component,
                data: {
                  name: name2
                }
              });
            }
            continue;
          }
          if (core.isInsideCreateElementProps(component, context)) {
            context.report({
              messageId: "nestedComponentInProps",
              node: component,
              data: {
                name: name2
              }
            });
            continue;
          }
          const maybeParentComponent = AST11__namespace.traverseUpGuard(component, isFunctionComponent);
          if (tools.O.isSome(maybeParentComponent) && !core.isDirectValueOfRenderPropertyLoose(maybeParentComponent.value)) {
            context.report({
              messageId: isInsideProperty ? "nestedComponentInProps" : "nestedComponent",
              node: component,
              data: {
                name: name2
              }
            });
            continue;
          }
          const isInsideClassComponentRenderMethod = core.isInsideRenderMethod(component);
          if (isInsideClassComponentRenderMethod) {
            context.report({
              messageId: "nestedComponent",
              node: component,
              data: {
                name: name2
              }
            });
          }
        }
        for (const { name: name2, node: component } of classComponents) {
          if (tools.O.isNone(AST11__namespace.traverseUp(component, (node2) => isClassComponent11(node2) || isFunctionComponent(node2)))) {
            continue;
          }
          context.report({
            messageId: "nestedComponent",
            node: component,
            data: {
              name: tools.O.getOrElse(() => "unknown")(name2)
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME30 = "no-prop-types";
var no_prop_types_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'propTypes' property in components"
    },
    messages: {
      noPropTypes: "[Deprecated] Use TypeScript or another type-checking solution instead."
    },
    schema: []
  },
  name: RULE_NAME30,
  create(context) {
    if (!context.sourceCode.text.includes("propTypes")) return {};
    return {
      AssignmentExpression(node) {
        if (node.operator !== "=" || node.left.type !== types.AST_NODE_TYPES.MemberExpression) return;
        const { object, property } = node.left;
        if (object.type !== types.AST_NODE_TYPES.Identifier) return;
        if (property.type !== types.AST_NODE_TYPES.Identifier || property.name !== "propTypes") return;
        if (!core.isComponentName(object.name)) return;
        const isComponent = tools.F.pipe(
          VAR__namespace.findVariable(object.name, context.sourceCode.getScope(node)),
          tools.O.flatMap(VAR__namespace.getVariableNode(0)),
          tools.O.exists((n) => AST11__namespace.isFunction(n) || core.isClassComponent(n))
        );
        if (!isComponent) return;
        context.report({ messageId: "noPropTypes", node: property });
      },
      PropertyDefinition(node) {
        if (!core.isClassComponent(node.parent.parent)) return;
        if (!node.static || node.key.type !== types.AST_NODE_TYPES.Identifier || node.key.name !== "propTypes") return;
        context.report({ messageId: "noPropTypes", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME31 = "no-redundant-should-component-update";
function isShouldComponentUpdate(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
var no_redundant_should_component_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'shouldComponentUpdate' in class component extends 'React.PureComponent'"
    },
    messages: {
      noRedundantShouldComponentUpdate: "'{{componentName}}' does not need 'shouldComponentUpdate' when extending 'React.PureComponent'."
    },
    schema: []
  },
  name: RULE_NAME31,
  create(context) {
    if (!context.sourceCode.text.includes("shouldComponentUpdate")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { name: name2, node: component, flag } of components.values()) {
          if (!(flag & core.ERClassComponentFlag.PureComponent)) continue;
          const { body } = component.body;
          for (const member of body) {
            if (isShouldComponentUpdate(member)) {
              context.report({
                messageId: "noRedundantShouldComponentUpdate",
                node: member,
                data: {
                  componentName: tools.O.getOrElse(() => "PureComponent")(name2)
                }
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME32 = "no-set-state-in-component-did-mount";
function isComponentDidMount(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
var no_set_state_in_component_did_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentDidMount'"
    },
    messages: {
      noSetStateInComponentDidMount: "Do not call `this.setState` in `componentDidMount` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME32,
  create(context) {
    if (!context.sourceCode.text.includes("componentDidMount")) return {};
    function getReportDescriptor(node) {
      if (!core.isThisSetState(node)) return tools.O.none();
      const maybeParentClass = AST11__namespace.traverseUp(
        node,
        AST11__namespace.isOneOf([types.AST_NODE_TYPES.ClassDeclaration, types.AST_NODE_TYPES.ClassExpression])
      );
      if (tools.O.isNone(maybeParentClass)) return tools.O.none();
      const parentClass = maybeParentClass.value;
      if (!core.isClassComponent(parentClass)) return tools.O.none();
      const maybeParentMethod = AST11__namespace.traverseUp(node, isComponentDidMount);
      if (tools.O.isNone(maybeParentMethod)) return tools.O.none();
      const parentMethod = maybeParentMethod.value;
      if (parentMethod.parent !== parentClass.body) return tools.O.none();
      if (context.sourceCode.getScope(node).upper !== context.sourceCode.getScope(parentMethod)) return tools.O.none();
      return tools.O.some({
        messageId: "noSetStateInComponentDidMount",
        node
      });
    }
    return {
      CallExpression: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME33 = "no-set-state-in-component-did-update";
function isComponentDidUpdate(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidUpdate";
}
var no_set_state_in_component_did_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentDidUpdate'"
    },
    messages: {
      noSetStateInComponentDidUpdate: "Do not call `this.setState` in `componentDidUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME33,
  create(context) {
    if (!context.sourceCode.text.includes("componentDidUpdate")) return {};
    function getReportDescriptor(node) {
      if (!core.isThisSetState(node)) return tools.O.none();
      const maybeParentClass = AST11__namespace.traverseUp(
        node,
        AST11__namespace.isOneOf([types.AST_NODE_TYPES.ClassDeclaration, types.AST_NODE_TYPES.ClassExpression])
      );
      if (tools.O.isNone(maybeParentClass)) return tools.O.none();
      const parentClass = maybeParentClass.value;
      if (!core.isClassComponent(parentClass)) return tools.O.none();
      const maybeParentMethod = AST11__namespace.traverseUp(node, isComponentDidUpdate);
      if (tools.O.isNone(maybeParentMethod)) return tools.O.none();
      const parentMethod = maybeParentMethod.value;
      if (parentMethod.parent !== parentClass.body) return tools.O.none();
      if (context.sourceCode.getScope(node).upper !== context.sourceCode.getScope(parentMethod)) return tools.O.none();
      return tools.O.some({
        messageId: "noSetStateInComponentDidUpdate",
        node
      });
    }
    return {
      CallExpression: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME34 = "no-set-state-in-component-will-update";
function isComponentWillUpdate3(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
var no_set_state_in_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentWillUpdate'"
    },
    messages: {
      noSetStateInComponentWillUpdate: "Do not call `this.setState` in `componentWillUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME34,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
    function getReportDescriptor(node) {
      if (!core.isThisSetState(node)) return tools.O.none();
      const maybeParentClass = AST11__namespace.traverseUp(
        node,
        AST11__namespace.isOneOf([types.AST_NODE_TYPES.ClassDeclaration, types.AST_NODE_TYPES.ClassExpression])
      );
      if (tools.O.isNone(maybeParentClass)) return tools.O.none();
      const parentClass = maybeParentClass.value;
      if (!core.isClassComponent(parentClass)) return tools.O.none();
      const maybeParentMethod = AST11__namespace.traverseUp(node, isComponentWillUpdate3);
      if (tools.O.isNone(maybeParentMethod)) return tools.O.none();
      const parentMethod = maybeParentMethod.value;
      if (parentMethod.parent !== parentClass.body) return tools.O.none();
      if (context.sourceCode.getScope(node).upper !== context.sourceCode.getScope(parentMethod)) return tools.O.none();
      return tools.O.some({
        messageId: "noSetStateInComponentWillUpdate",
        node
      });
    }
    return {
      CallExpression: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME35 = "no-string-refs";
function containsStringLiteral({ value }) {
  return value?.type === types.AST_NODE_TYPES.Literal && tools.isString(value.value);
}
function containsStringExpressionContainer({ value }) {
  if (value?.type !== types.AST_NODE_TYPES.JSXExpressionContainer) return false;
  if (value.expression.type === types.AST_NODE_TYPES.Literal) return tools.isString(value.expression.value);
  return value.expression.type === types.AST_NODE_TYPES.TemplateLiteral;
}
var no_string_refs_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using deprecated string refs"
    },
    messages: {
      noStringRefs: "[Deprecated] Use callback refs instead."
    },
    schema: []
  },
  name: RULE_NAME35,
  create(context) {
    return {
      JSXAttribute(node) {
        if (node.name.name !== "ref") return;
        if (containsStringLiteral(node) || containsStringExpressionContainer(node)) {
          context.report({
            messageId: "noStringRefs",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME36 = "no-unsafe-component-will-mount";
function isUnsafeComponentWillMount(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
var no_unsafe_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillMount'"
    },
    messages: {
      noUnsafeComponentWillMount: "Do not use 'UNSAFE_componentWillMount'."
    },
    schema: []
  },
  name: RULE_NAME36,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillMount")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillMount(member)) {
              context.report({
                messageId: "noUnsafeComponentWillMount",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME37 = "no-unsafe-component-will-receive-props";
function isUnsafeComponentWillReceiveProps(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
var no_unsafe_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillReceiveProps'"
    },
    messages: {
      noUnsafeComponentWillReceiveProps: "Do not use 'UNSAFE_componentWillReceiveProps'."
    },
    schema: []
  },
  name: RULE_NAME37,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillReceiveProps")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillReceiveProps(member)) {
              context.report({
                messageId: "noUnsafeComponentWillReceiveProps",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME38 = "no-unsafe-component-will-update";
function isUnsafeComponentWillUpdate(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
var no_unsafe_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillUpdate'"
    },
    messages: {
      noUnsafeComponentWillUpdate: "Do not use 'UNSAFE_componentWillUpdate'."
    },
    schema: []
  },
  name: RULE_NAME38,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillUpdate")) return {};
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillUpdate(member)) {
              context.report({
                messageId: "noUnsafeComponentWillUpdate",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME39 = "no-unstable-context-value";
var no_unstable_context_value_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow passing constructed values to context providers"
    },
    messages: {
      noUnstableContextValue: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render.",
      noUnstableContextValueWithFunction: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. Consider wrapping it in a useCallback hook.",
      noUnstableContextValueWithIdentifier: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. Consider wrapping it in a useMemo hook."
    },
    schema: []
  },
  name: RULE_NAME39,
  create(context) {
    const { ctx, listeners } = core.useComponentCollector(context);
    const possibleValueConstructions = /* @__PURE__ */ new Map();
    return {
      ...listeners,
      JSXOpeningElement(node) {
        const openingElementName = node.name;
        if (openingElementName.type !== types.AST_NODE_TYPES.JSXMemberExpression) return;
        if (openingElementName.property.name !== "Provider") return;
        const maybeJSXValueAttribute = tools.O.fromNullable(
          node.attributes.find((attribute) => {
            return attribute.type === types.AST_NODE_TYPES.JSXAttribute && attribute.name.name === "value";
          })
        );
        if (tools.O.isNone(maybeJSXValueAttribute) || !("value" in maybeJSXValueAttribute.value)) return;
        const valueNode = maybeJSXValueAttribute.value.value;
        if (valueNode?.type !== types.AST_NODE_TYPES.JSXExpressionContainer) return;
        const valueExpression = valueNode.expression;
        const initialScope = context.sourceCode.getScope(valueExpression);
        const construction = VAR__namespace.inspectConstruction(valueExpression, initialScope);
        if (construction._tag === "None") return;
        tools.O.map(
          ctx.getCurrentFunction(),
          ([_, currentFn]) => possibleValueConstructions.set(currentFn, [
            ...possibleValueConstructions.get(currentFn) ?? [],
            construction
          ])
        );
      },
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node).values();
        for (const { node: component } of components) {
          const constructions = possibleValueConstructions.get(component);
          if (!constructions) continue;
          for (const construction of constructions) {
            if (construction._tag === "None") continue;
            const { node: constructionNode, _tag } = construction;
            const messageId = _tag.startsWith("Function") ? "noUnstableContextValueWithFunction" : "noUnstableContextValueWithIdentifier";
            context.report({
              messageId,
              node: constructionNode,
              data: {
                type: AST11__namespace.toReadableNodeType(constructionNode)
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME40 = "no-unstable-default-props";
var no_unstable_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using unstable value as default param in function component"
    },
    messages: {
      noUnstableDefaultProps: "A/an '{{forbiddenType}}' as default prop. This could lead to potential infinite render loop in React. Use a variable instead of '{{forbiddenType}}'."
    },
    schema: []
  },
  name: RULE_NAME40,
  create(context) {
    const { ctx, listeners } = core.useComponentCollector(context);
    const possibleDestructuringDeclarators = /* @__PURE__ */ new WeakMap();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { params } = component;
          const [props] = params;
          if (!props) continue;
          const properties = tsPattern.match(props).with({ type: types.AST_NODE_TYPES.ObjectPattern }, ({ properties: properties2 }) => properties2).with({ type: types.AST_NODE_TYPES.Identifier }, ({ name: name2 }) => {
            const variableDeclarators = possibleDestructuringDeclarators.get(component);
            if (!variableDeclarators) return [];
            const declarators = variableDeclarators.filter((d) => d.init.name === name2);
            return declarators.flatMap((d) => d.id.properties);
          }).otherwise(() => []);
          for (const prop of properties) {
            if (prop.type !== types.AST_NODE_TYPES.Property || prop.value.type !== types.AST_NODE_TYPES.AssignmentPattern) continue;
            const { value } = prop;
            const { right } = value;
            const initialScope = context.sourceCode.getScope(value);
            const construction = VAR__namespace.inspectConstruction(
              value,
              initialScope,
              VAR__namespace.ConstructionHint.StrictCallExpression
            );
            if (construction._tag === "None") continue;
            const forbiddenType = AST11__namespace.toReadableNodeType(right);
            context.report({
              messageId: "noUnstableDefaultProps",
              node: right,
              data: {
                forbiddenType
              }
            });
          }
        }
      },
      "VariableDeclarator[id.type='ObjectPattern'][init.type='Identifier']"(node) {
        tools.O.map(
          ctx.getCurrentFunction(),
          ([_, currentFn]) => possibleDestructuringDeclarators.set(currentFn, [
            ...possibleDestructuringDeclarators.get(currentFn) ?? [],
            node
          ])
        );
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME41 = "no-unused-class-component-members";
var LIFECYCLE_METHODS = /* @__PURE__ */ new Set([
  "componentDidCatch",
  "componentDidMount",
  "componentDidUpdate",
  "componentWillMount",
  "componentWillReceiveProps",
  "componentWillUnmount",
  "componentWillUpdate",
  "constructor",
  "getSnapshotBeforeUpdate",
  "render",
  "shouldComponentUpdate",
  "state",
  "UNSAFE_componentWillMount",
  "UNSAFE_componentWillReceiveProps",
  "UNSAFE_componentWillUpdate"
]);
function getName3(node) {
  if (node.type === types.AST_NODE_TYPES.TSAsExpression) {
    return getName3(node.expression);
  }
  if (node.type === types.AST_NODE_TYPES.Identifier || node.type === types.AST_NODE_TYPES.PrivateIdentifier) {
    return tools.O.some(node.name);
  }
  if (node.type === types.AST_NODE_TYPES.Literal) {
    return tools.O.some(String(node.value));
  }
  if (node.type === types.AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return tools.O.fromNullable(node.quasis[0]?.value.raw);
  }
  return tools.O.none();
}
var no_unused_class_component_members_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused class component members"
    },
    messages: {
      noUnusedClassComponentMembers: "Unused method or property '{{methodName}}'' of class '{{className}}'."
    },
    schema: []
  },
  name: RULE_NAME41,
  create(context) {
    const classStack = [];
    const methodStack = [];
    const propertyDefs = /* @__PURE__ */ new WeakMap();
    const propertyUsages = /* @__PURE__ */ new WeakMap();
    function classEnter(node) {
      classStack.push(node);
      if (!core.isClassComponent(node)) return;
      propertyDefs.set(node, /* @__PURE__ */ new Set());
      propertyUsages.set(node, /* @__PURE__ */ new Set());
    }
    function classExit() {
      const currentClass = classStack.pop();
      if (!currentClass || !core.isClassComponent(currentClass)) return;
      const className = tools.O.map(AST11__namespace.getClassIdentifier(currentClass), (id) => id.name);
      const defs = propertyDefs.get(currentClass);
      const usages = propertyUsages.get(currentClass);
      if (!defs) return;
      for (const def of defs) {
        const name2 = getName3(def);
        if (tools.O.isNone(name2)) continue;
        if (usages?.has(name2.value) || LIFECYCLE_METHODS.has(name2.value)) continue;
        context.report({
          messageId: "noUnusedClassComponentMembers",
          node: def,
          data: {
            className: tools.O.getOrElse(className, () => "Component"),
            methodName: name2.value
          }
        });
      }
    }
    function methodEnter(node) {
      methodStack.push(node);
      const currentClass = classStack.at(-1);
      if (!currentClass || !core.isClassComponent(currentClass)) return;
      if (node.static) return;
      if (AST11__namespace.isKeyLiteralLike(node, node.key)) {
        propertyDefs.get(currentClass)?.add(node.key);
      }
    }
    function methodExit() {
      methodStack.pop();
    }
    return {
      ClassDeclaration: classEnter,
      "ClassDeclaration:exit": classExit,
      ClassExpression: classEnter,
      "ClassExpression:exit": classExit,
      MemberExpression(node) {
        const currentClass = classStack.at(-1);
        const currentMethod = methodStack.at(-1);
        if (!currentClass || !currentMethod) return;
        if (!core.isClassComponent(currentClass) || currentMethod.static) return;
        if (!AST11__namespace.isThisExpression(node.object) || !AST11__namespace.isKeyLiteralLike(node, node.property)) return;
        if (node.parent.type === types.AST_NODE_TYPES.AssignmentExpression && node.parent.left === node) {
          propertyDefs.get(currentClass)?.add(node.property);
          return;
        }
        tools.O.map(getName3(node.property), (name2) => propertyUsages.get(currentClass)?.add(name2));
      },
      MethodDefinition: methodEnter,
      "MethodDefinition:exit": methodExit,
      PropertyDefinition: methodEnter,
      "PropertyDefinition:exit": methodExit,
      VariableDeclarator(node) {
        const currentClass = classStack.at(-1);
        const currentMethod = methodStack.at(-1);
        if (!currentClass || !currentMethod) return;
        if (!core.isClassComponent(currentClass) || currentMethod.static) return;
        if (node.init && AST11__namespace.isThisExpression(node.init) && node.id.type === types.AST_NODE_TYPES.ObjectPattern) {
          for (const prop of node.id.properties) {
            if (prop.type === types.AST_NODE_TYPES.Property && AST11__namespace.isKeyLiteralLike(prop, prop.key)) {
              tools.O.map(getName3(prop.key), (name2) => propertyUsages.get(currentClass)?.add(name2));
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME42 = "no-unused-state";
function getName4(node) {
  if (node.type === types.AST_NODE_TYPES.TSAsExpression) {
    return getName4(node.expression);
  }
  if (node.type === types.AST_NODE_TYPES.Identifier || node.type === types.AST_NODE_TYPES.PrivateIdentifier) {
    return tools.O.some(node.name);
  }
  if (node.type === types.AST_NODE_TYPES.Literal) {
    return tools.O.some(String(node.value));
  }
  if (node.type === types.AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return tools.O.fromNullable(node.quasis[0]?.value.raw);
  }
  return tools.O.none();
}
function isAssignmentToThisState2(node) {
  const { left } = node;
  return left.type === types.AST_NODE_TYPES.MemberExpression && AST11__namespace.isThisExpression(left.object) && tools.O.exists(getName4(left.property), (name2) => name2 === "state");
}
var isGetDerivedStateFromProps = tsPattern.isMatching({
  key: {
    name: "getDerivedStateFromProps"
  },
  static: true,
  value: {
    params: tsPattern.P.array()
  }
});
var no_unused_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused state of class component"
    },
    messages: {
      noUnusedState: "Unused class component state in '{{className}}'"
    },
    schema: []
  },
  name: RULE_NAME42,
  create(context) {
    const classStack = [];
    const methodStack = [];
    const constructorStack = [];
    const stateDefs = /* @__PURE__ */ new WeakMap();
    function classEnter(node) {
      classStack.push(node);
    }
    function classExit() {
      const currentClass = classStack.pop();
      if (!currentClass || !core.isClassComponent(currentClass)) return;
      const className = tools.O.map(AST11__namespace.getClassIdentifier(currentClass), (id) => id.name);
      const [def, isUsed] = stateDefs.get(currentClass) ?? [tools.O.none(), false];
      if (tools.O.isNone(def) || isUsed) return;
      context.report({
        messageId: "noUnusedState",
        node: def.value,
        data: {
          className: tools.O.getOrElse(className, () => "Component")
        }
      });
    }
    function methodEnter(node) {
      methodStack.push(node);
      const currentClass = classStack.at(-1);
      if (!currentClass || !core.isClassComponent(currentClass)) return;
      if (node.static) {
        if (isGetDerivedStateFromProps(node) && node.value.params.length > 1) {
          const [def] = stateDefs.get(currentClass) ?? [tools.O.none()];
          stateDefs.set(currentClass, [def, true]);
        }
        return;
      }
      if (tools.O.exists(getName4(node.key), (name2) => name2 === "state")) {
        stateDefs.set(currentClass, [tools.O.some(node.key), false]);
      }
    }
    function methodExit() {
      methodStack.pop();
    }
    function constructorEnter(node) {
      constructorStack.push(node);
    }
    function constructorExit() {
      constructorStack.pop();
    }
    return {
      AssignmentExpression(node) {
        if (!isAssignmentToThisState2(node)) return;
        const currentClass = classStack.at(-1);
        if (!currentClass || !core.isClassComponent(currentClass)) return;
        const currentConstructor = constructorStack.at(-1);
        if (!currentConstructor || !currentClass.body.body.includes(currentConstructor)) return;
        const [_, isUsed] = stateDefs.get(currentClass) ?? [tools.O.none(), false];
        stateDefs.set(currentClass, [tools.O.some(node.left), isUsed]);
      },
      ClassDeclaration: classEnter,
      "ClassDeclaration:exit": classExit,
      ClassExpression: classEnter,
      "ClassExpression:exit": classExit,
      MemberExpression(node) {
        if (!AST11__namespace.isThisExpression(node.object)) return;
        if (!tools.O.exists(getName4(node.property), (name2) => name2 === "state")) return;
        const currentClass = classStack.at(-1);
        if (!currentClass || !core.isClassComponent(currentClass)) return;
        const currentMethod = methodStack.at(-1);
        if (!currentMethod || currentMethod.static) return;
        if (currentMethod === constructorStack.at(-1)) return;
        if (!currentClass.body.body.includes(currentMethod)) return;
        const [def] = stateDefs.get(currentClass) ?? [tools.O.none(), false];
        stateDefs.set(currentClass, [def, true]);
      },
      MethodDefinition: methodEnter,
      "MethodDefinition:exit": methodExit,
      "MethodDefinition[key.name='constructor']": constructorEnter,
      "MethodDefinition[key.name='constructor']:exit": constructorExit,
      PropertyDefinition: methodEnter,
      "PropertyDefinition:exit": methodExit,
      VariableDeclarator(node) {
        const currentClass = classStack.at(-1);
        if (!currentClass || !core.isClassComponent(currentClass)) return;
        const currentMethod = methodStack.at(-1);
        if (!currentMethod || currentMethod.static) return;
        if (currentMethod === constructorStack.at(-1)) return;
        if (!currentClass.body.body.includes(currentMethod)) return;
        if (!(node.init && AST11__namespace.isThisExpression(node.init) && node.id.type === types.AST_NODE_TYPES.ObjectPattern)) return;
        const hasState = node.id.properties.some((prop) => {
          if (prop.type === types.AST_NODE_TYPES.Property && AST11__namespace.isKeyLiteralLike(prop, prop.key)) {
            return tools.O.exists(getName4(prop.key), (name2) => name2 === "state");
          }
          return false;
        });
        if (!hasState) return;
        const [def] = stateDefs.get(currentClass) ?? [tools.O.none(), false];
        stateDefs.set(currentClass, [def, true]);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME43 = "no-useless-fragment";
function check(node, context, allowExpressions) {
  const initialScope = context.sourceCode.getScope(node);
  if (JSX7__namespace.isKeyedElement(node, initialScope)) return;
  if (JSX7__namespace.isBuiltInElement(node.parent)) context.report({ messageId: "noUselessFragmentInBuiltIn", node });
  if (node.children.length === 0) return context.report({ messageId: "noUselessFragment", node });
  const isChildren = AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXElement, types.AST_NODE_TYPES.JSXFragment])(node.parent);
  const [firstChildren] = node.children;
  if (allowExpressions && node.children.length === 1 && JSX7__namespace.isLiteral(firstChildren) && !isChildren) return;
  if (!allowExpressions && isChildren) {
    return context.report({ messageId: "noUselessFragment", node });
  } else if (!allowExpressions && !isChildren && node.children.length === 1) {
    return context.report({ messageId: "noUselessFragment", node });
  }
  const nonPaddingChildren = node.children.filter((child) => !JSX7__namespace.isPaddingSpaces(child));
  if (nonPaddingChildren.length > 1) return;
  if (nonPaddingChildren.length === 0) return context.report({ messageId: "noUselessFragment", node });
  const [first] = nonPaddingChildren;
  if (tsPattern.isMatching({ type: types.AST_NODE_TYPES.JSXExpressionContainer, expression: tsPattern.P.not(types.AST_NODE_TYPES.CallExpression) }, first)) return;
  context.report({ messageId: "noUselessFragment", node });
}
var no_useless_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unnecessary fragments"
    },
    messages: {
      noUselessFragment: "A fragment contains less than two children is unnecessary.",
      noUselessFragmentInBuiltIn: "A fragment placed inside a built-in component is unnecessary."
    },
    schema: [{
      type: "object",
      additionalProperties: false,
      properties: {
        allowExpressions: {
          type: "boolean",
          description: "Allow fragments with a single expression child"
        }
      }
    }]
  },
  name: RULE_NAME43,
  create(context, [option]) {
    const { allowExpressions = true } = option;
    return {
      JSXElement(node) {
        if (!core.isFragmentElement(node, context)) return;
        check(node, context, allowExpressions);
      },
      JSXFragment(node) {
        check(node, context, allowExpressions);
      }
    };
  },
  defaultOptions: [{
    allowExpressions: true
  }]
});
var RULE_NAME44 = "prefer-destructuring-assignment";
function isMemberExpressionWithObjectName(node) {
  return node.object.type === types.AST_NODE_TYPES.Identifier && "name" in node.object;
}
var prefer_destructuring_assignment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce using destructuring assignment in component props and context"
    },
    messages: {
      preferDestructuringAssignment: "Use destructuring assignment for {{name}}."
    },
    schema: []
  },
  name: RULE_NAME44,
  create(context) {
    const { ctx, listeners } = core.useComponentCollector(context);
    const memberExpressionWithNames = [];
    return {
      ...listeners,
      MemberExpression(node) {
        if (isMemberExpressionWithObjectName(node)) {
          const scope = context.sourceCode.getScope(node);
          memberExpressionWithNames.push([scope, node]);
        }
      },
      "Program:exit"(node) {
        const components = Array.from(ctx.getAllComponents(node).values());
        function isFunctionComponent(block) {
          if (!AST11__namespace.isFunction(block)) return false;
          const maybeId = AST11__namespace.getFunctionIdentifier(block);
          return tools.O.isSome(maybeId) && core.isComponentName(maybeId.value.name) && components.some((component) => component.node === block);
        }
        for (const [initialScope, memberExpression] of memberExpressionWithNames) {
          let scope = initialScope;
          let isComponent = isFunctionComponent(scope.block);
          while (!isComponent && scope.upper && scope.upper !== scope) {
            scope = scope.upper;
            isComponent = isFunctionComponent(scope.block);
          }
          if (!isComponent) continue;
          const component = scope.block;
          if (!("params" in component)) continue;
          const [props, ctx2] = component.params;
          const isMatch = tsPattern.isMatching({ name: memberExpression.object.name });
          if (isMatch(props)) {
            context.report({
              messageId: "preferDestructuringAssignment",
              node: memberExpression,
              data: {
                name: "props"
              }
            });
          }
          if (isMatch(ctx2)) {
            context.report({
              messageId: "preferDestructuringAssignment",
              node: memberExpression,
              data: {
                name: "context"
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME45 = "prefer-react-namespace-import";
var prefer_react_namespace_import_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce React is imported via a namespace import"
    },
    fixable: "code",
    messages: {
      preferReactNamespaceImport: 'Prefer importing React as `import * as React from "{{importSource}}";`'
    },
    schema: []
  },
  name: RULE_NAME45,
  create(context) {
    const importSource = shared.decodeSettings(context.settings).importSource ?? "react";
    return {
      [`ImportDeclaration[source.value="${importSource}"] ImportDefaultSpecifier`](node) {
        const hasOtherSpecifiers = node.parent.specifiers.length > 1;
        context.report({
          messageId: "preferReactNamespaceImport",
          node: hasOtherSpecifiers ? node : node.parent,
          data: { importSource },
          fix(fixer) {
            const quote = node.parent.source.raw.at(0) ?? "'";
            const isTypeImport = node.parent.importKind === "type";
            const importStringPrefix = `import${isTypeImport ? " type" : ""}`;
            const importSourceQuoted = `${quote}${importSource}${quote}`;
            const sourceCode = context.sourceCode.getText(node.parent);
            const semiColon = sourceCode.endsWith(";") ? ";" : "";
            if (!hasOtherSpecifiers) {
              return fixer.replaceText(
                node.parent,
                `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semiColon}`
              );
            }
            const specifiers = sourceCode.slice(sourceCode.indexOf("{"), sourceCode.indexOf("}") + 1);
            return fixer.replaceText(
              node.parent,
              `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semiColon}
${importStringPrefix} ${specifiers} from ${importSourceQuoted}${semiColon}`
            );
          }
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME46 = "prefer-read-only-props";
function isReadonlyType(type, services) {
  try {
    const im = isImmutableType.getTypeImmutability(services.program, type);
    return isImmutableType.isUnknown(im) || isImmutableType.isImmutable(im) || isImmutableType.isReadonlyShallow(im) || isImmutableType.isReadonlyDeep(im);
  } catch {
    return true;
  }
}
var prefer_read_only_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce read-only props in components"
    },
    messages: {
      preferReadOnlyProps: "A function component's props should be read-only."
    },
    schema: []
  },
  name: RULE_NAME46,
  create(context) {
    const services = utils.ESLintUtils.getParserServices(context, false);
    const { ctx, listeners } = core.useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const [_, component] of components) {
          const [props] = component.node.params;
          if (!props) continue;
          const propsType = typeUtils.getConstrainedTypeAtLocation(services, props);
          if (typeUtils.isTypeReadonly(services.program, propsType) || isReadonlyType(propsType, services)) continue;
          context.report({ messageId: "preferReadOnlyProps", node: props });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME47 = "prefer-shorthand-boolean";
var prefer_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce using shorthand boolean attributes"
    },
    fixable: "code",
    messages: {
      preferShorthandBoolean: "Use shorthand boolean attribute '{{propName}}'."
    },
    schema: []
  },
  name: RULE_NAME47,
  create(context) {
    function getReportDescriptor(node) {
      const { value } = node;
      const propName = JSX7__namespace.getPropName(node);
      const hasValueTrue = value?.type === types.AST_NODE_TYPES.JSXExpressionContainer && value.expression.type === types.AST_NODE_TYPES.Literal && value.expression.value === true;
      if (!hasValueTrue) return tools.O.none();
      return tools.O.some({
        messageId: "preferShorthandBoolean",
        node,
        data: {
          propName
        },
        fix: (fixer) => fixer.removeRange([node.name.range[1], value.range[1]])
      });
    }
    return {
      JSXAttribute: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME48 = "prefer-shorthand-fragment";
var prefer_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce using fragment syntax instead of 'Fragment' component"
    },
    messages: {
      preferShorthandFragment: "Use fragment shorthand syntax instead of 'Fragment' component."
    },
    schema: []
  },
  name: RULE_NAME48,
  create(context) {
    function getReportDescriptor(node) {
      if (!core.isFragmentElement(node, context)) return tools.O.none();
      const hasAttributes = node.openingElement.attributes.length > 0;
      if (hasAttributes) return tools.O.none();
      return tools.O.some({
        messageId: "preferShorthandFragment",
        node
      });
    }
    return {
      JSXElement: tools.F.flow(getReportDescriptor, tools.O.map(context.report))
    };
  },
  defaultOptions: []
});

// src/index.ts
var DEFAULT_ESLINT_REACT_SETTINGS = {
  additionalHooks: {
    useLayoutEffect: ["useIsomorphicLayoutEffect"]
  },
  polymorphicPropName: "as",
  skipImportCheck: false,
  version: "detect"
};
var src_default = {
  meta: {
    name,
    version
  },
  rules: {
    "avoid-shorthand-boolean": avoid_shorthand_boolean_default,
    "avoid-shorthand-fragment": avoid_shorthand_fragment_default,
    "ensure-forward-ref-using-ref": ensure_forward_ref_using_ref_default,
    "jsx-no-duplicate-props": jsx_no_duplicate_props_default,
    "jsx-uses-vars": jsx_uses_vars_default,
    "no-access-state-in-setstate": no_access_state_in_setstate_default,
    "no-array-index-key": no_array_index_key_default,
    "no-children-count": no_children_count_default,
    "no-children-for-each": no_children_for_each_default,
    "no-children-map": no_children_map_default,
    "no-children-only": no_children_only_default,
    "no-children-prop": no_children_prop_default,
    "no-children-to-array": no_children_to_array_default,
    "no-class-component": no_class_component_default,
    "no-clone-element": no_clone_element_default,
    "no-comment-textnodes": no_comment_textnodes_default,
    "no-complex-conditional-rendering": no_complex_conditional_rendering_default,
    "no-component-will-mount": no_component_will_mount_default,
    "no-component-will-receive-props": no_component_will_receive_props_default,
    "no-component-will-update": no_component_will_update_default,
    "no-create-ref": no_create_ref_default,
    "no-default-props": no_default_props_default,
    "no-direct-mutation-state": no_direct_mutation_state_default,
    "no-duplicate-key": no_duplicate_key_default,
    "no-implicit-key": no_implicit_key_default,
    "no-leaked-conditional-rendering": no_leaked_conditional_rendering_default,
    "no-missing-component-display-name": no_missing_component_display_name_default,
    "no-missing-key": no_missing_key_default,
    "no-nested-components": no_nested_components_default,
    "no-prop-types": no_prop_types_default,
    "no-redundant-should-component-update": no_redundant_should_component_update_default,
    "no-set-state-in-component-did-mount": no_set_state_in_component_did_mount_default,
    "no-set-state-in-component-did-update": no_set_state_in_component_did_update_default,
    "no-set-state-in-component-will-update": no_set_state_in_component_will_update_default,
    "no-string-refs": no_string_refs_default,
    "no-unsafe-component-will-mount": no_unsafe_component_will_mount_default,
    "no-unsafe-component-will-receive-props": no_unsafe_component_will_receive_props_default,
    "no-unsafe-component-will-update": no_unsafe_component_will_update_default,
    "no-unstable-context-value": no_unstable_context_value_default,
    "no-unstable-default-props": no_unstable_default_props_default,
    "no-unused-class-component-members": no_unused_class_component_members_default,
    "no-unused-state": no_unused_state_default,
    "no-useless-fragment": no_useless_fragment_default,
    "prefer-destructuring-assignment": prefer_destructuring_assignment_default,
    "prefer-react-namespace-import": prefer_react_namespace_import_default,
    "prefer-read-only-props": prefer_read_only_props_default,
    "prefer-shorthand-boolean": prefer_shorthand_boolean_default,
    "prefer-shorthand-fragment": prefer_shorthand_fragment_default,
    // Deprecated Rules
    /** @deprecated Use `no-complex-conditional-rendering` instead. */
    "no-complicated-conditional-rendering": no_complex_conditional_rendering_default
  },
  DEFAULT_ESLINT_REACT_SETTINGS
};

module.exports = src_default;
