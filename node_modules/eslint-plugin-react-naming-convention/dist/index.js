'use strict';

var AST = require('@eslint-react/ast');
var core = require('@eslint-react/core');
var JSX = require('@eslint-react/jsx');
var shared = require('@eslint-react/shared');
var tools = require('@eslint-react/tools');
var tsPattern = require('ts-pattern');
var path = require('path');
var types = require('@typescript-eslint/types');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST__namespace = /*#__PURE__*/_interopNamespace(AST);
var JSX__namespace = /*#__PURE__*/_interopNamespace(JSX);
var path__default = /*#__PURE__*/_interopDefault(path);

// package.json
var name = "eslint-plugin-react-naming-convention";
var version = "1.16.1";
var createRule = shared.createRuleForPlugin("naming-convention");

// src/rules/component-name.ts
var RULE_NAME = "component-name";
var defaultOptions = [
  {
    allowAllCaps: false,
    allowLeadingUnderscore: false,
    allowNamespace: false,
    excepts: [],
    rule: "PascalCase"
  }
];
var schema = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["PascalCase", "CONSTANT_CASE"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          allowAllCaps: { type: "boolean" },
          allowLeadingUnderscore: { type: "boolean" },
          allowNamespace: { type: "boolean" },
          excepts: {
            type: "array",
            items: { type: "string", format: "regex" }
          },
          rule: {
            type: "string",
            enum: ["PascalCase", "CONSTANT_CASE"]
          }
        }
      }
    ]
  }
];
function normalizeOptions(options) {
  const [opts] = options;
  if (tools.isNullable(opts)) return defaultOptions[0];
  if (tools.isString(opts)) return { ...defaultOptions[0], rule: opts };
  return {
    ...opts,
    excepts: opts.excepts?.map((pattern) => new RegExp(pattern, "u")) ?? []
  };
}
function validate(name2, options) {
  if (options.excepts.some((regex) => regex.test(name2))) return true;
  let normalized = name2.normalize("NFKD").replace(/[\u0300-\u036F]/g, "");
  normalized = normalized.split(".").at(-1) ?? normalized;
  if (options.allowNamespace) {
    normalized = normalized.replace(":", "");
  }
  if (options.allowLeadingUnderscore) {
    normalized = normalized.replace(/^_/, "");
  }
  return tsPattern.match(options.rule).with("CONSTANT_CASE", () => shared.RE_CONSTANT_CASE.test(normalized)).with("PascalCase", () => {
    if ([...normalized].length > 3 && /^[A-Z]+$/u.test(normalized)) return options.allowAllCaps;
    return shared.RE_PASCAL_CASE.test(normalized);
  }).otherwise(tools.F.constFalse);
}
var component_name_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce component naming convention to 'PascalCase' or 'CONSTANT_CASE'"
    },
    messages: {
      componentName: "A component name must be in {{case}}."
    },
    schema
  },
  name: RULE_NAME,
  create(context) {
    const options = normalizeOptions(context.options);
    const collector = core.useComponentCollector(context);
    const collectorLegacy = core.useComponentCollectorLegacy();
    return {
      ...collector.listeners,
      ...collectorLegacy.listeners,
      JSXOpeningElement(node) {
        const name2 = JSX__namespace.getElementName(node);
        if (/^[a-z]/u.test(name2)) return;
        if (validate(name2, options)) return;
        context.report({
          messageId: "componentName",
          node,
          data: {
            case: options.rule
          }
        });
      },
      "Program:exit"(node) {
        const functionComponents = collector.ctx.getAllComponents(node);
        const classComponents = collectorLegacy.ctx.getAllComponents(node);
        for (const { node: component } of functionComponents.values()) {
          const maybeId = AST__namespace.getFunctionIdentifier(component);
          if (tools.O.isNone(maybeId)) continue;
          const id = maybeId.value;
          const { name: name2 } = id;
          if (validate(name2, options)) continue;
          context.report({
            messageId: "componentName",
            node: id,
            data: {
              case: options.rule
            }
          });
        }
        for (const { node: component } of classComponents.values()) {
          const maybeId = AST__namespace.getClassIdentifier(component);
          if (tools.O.isNone(maybeId)) continue;
          const id = maybeId.value;
          const { name: name2 } = id;
          if (validate(name2, options)) continue;
          context.report({
            messageId: "componentName",
            node: id,
            data: {
              case: options.rule
            }
          });
        }
      }
    };
  },
  defaultOptions
});

// ../../../node_modules/.pnpm/string-ts@2.2.0/node_modules/string-ts/dist/index.mjs
function charAt(str, index) {
  return str.charAt(index);
}
function join(tuple, delimiter = "") {
  return tuple.join(delimiter);
}
function replaceAll(sentence, lookup, replacement = "") {
  if (typeof sentence.replaceAll === "function") {
    return sentence.replaceAll(lookup, replacement);
  }
  const regex = new RegExp(lookup, "g");
  return sentence.replace(regex, replacement);
}
function slice(str, start = 0, end = void 0) {
  return str.slice(start, end);
}
function toLowerCase(str) {
  return str.toLowerCase();
}
function toUpperCase(str) {
  return str.toUpperCase();
}
var UNESCAPED_SEPARATORS = [
  "[",
  "]",
  "{",
  "}",
  "(",
  ")",
  "|",
  "/",
  "-",
  "\\"
];
var SEPARATORS = [...UNESCAPED_SEPARATORS, " ", "_", "."];
function escapeChar(char) {
  return UNESCAPED_SEPARATORS.includes(char) ? `\\${char}` : char;
}
var SEPARATOR_REGEX = new RegExp(
  `[${SEPARATORS.map(escapeChar).join("")}]`,
  "g"
);
function words(sentence) {
  return sentence.replace(SEPARATOR_REGEX, " ").replace(/([a-zA-Z])([0-9])/g, "$1 $2").replace(/([0-9])([a-zA-Z])/g, "$1 $2").replace(/([a-zA-Z0-9_\-./])([^a-zA-Z0-9_\-./'])/g, "$1 $2").replace(/([^a-zA-Z0-9_\-./'])([a-zA-Z0-9_\-./])/g, "$1 $2").replace(/([a-z])([A-Z])/g, "$1 $2").replace(/([A-Z])([A-Z][a-z])/g, "$1 $2").trim().split(/\s+/g);
}
function capitalize(str) {
  return join([
    toUpperCase(charAt(str, 0) ?? ""),
    slice(str, 1)
  ]);
}
function pascalCaseAll(words2) {
  return words2.map((v) => capitalize(toLowerCase(v)));
}
function removeApostrophe(str) {
  return replaceAll(str, "'", "");
}
function pascalCase(str) {
  return join(pascalCaseAll(words(removeApostrophe(str))));
}
function uncapitalize(str) {
  return join([
    toLowerCase(charAt(str, 0) ?? ""),
    slice(str, 1)
  ]);
}
function camelCase(str) {
  return uncapitalize(pascalCase(removeApostrophe(str)));
}
function delimiterCase(str, delimiter) {
  return join(words(removeApostrophe(str)), delimiter);
}
function kebabCase(str) {
  return toLowerCase(delimiterCase(removeApostrophe(str), "-"));
}
function snakeCase(str) {
  return toLowerCase(delimiterCase(removeApostrophe(str), "_"));
}
var RULE_NAME2 = "filename";
var defaultOptions2 = [
  {
    excepts: ["^index$"],
    extensions: [".jsx", ".tsx"],
    rule: "PascalCase"
  }
];
var schema2 = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["PascalCase", "camelCase", "kebab-case", "snake_case"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          excepts: {
            type: "array",
            items: { type: "string", format: "regex" }
          },
          extensions: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true
          },
          rule: {
            type: "string",
            enum: ["PascalCase", "camelCase", "kebab-case", "snake_case"]
          }
        }
      }
    ]
  }
];
var filename_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce naming convention for JSX filenames"
    },
    messages: {
      // filenameCaseMismatch: "A file with name '{{name}}' does not match {{rule}}.",
      filenameCaseMismatchSuggestion: "A file with name '{{name}}' does not match {{rule}}. Should rename to '{{suggestion}}'.",
      filenameEmpty: "A file must have non-empty name."
    },
    schema: schema2
  },
  name: RULE_NAME2,
  create(context) {
    const options = context.options[0] ?? defaultOptions2[0];
    const rule = tools.isString(options) ? options : options.rule ?? "PascalCase";
    const excepts = tools.isString(options) ? [] : options.excepts ?? [];
    const extensions = tools.isObject(options) && "extensions" in options ? options.extensions : defaultOptions2[0].extensions;
    const filename = context.filename;
    const fileNameExt = filename.slice(filename.lastIndexOf("."));
    if (!extensions.includes(fileNameExt)) return {};
    function validate2(name2, casing = rule, ignores = excepts) {
      if (ignores.map((pattern) => new RegExp(pattern, "u")).some((pattern) => pattern.test(name2))) {
        return true;
      }
      return tsPattern.match(casing).with("PascalCase", () => shared.RE_PASCAL_CASE.test(name2)).with("camelCase", () => shared.RE_CAMEL_CASE.test(name2)).with("kebab-case", () => shared.RE_KEBAB_CASE.test(name2)).with("snake_case", () => shared.RE_SNAKE_CASE.test(name2)).exhaustive();
    }
    function getSuggestion(name2, casing = rule) {
      return tsPattern.match(casing).with("PascalCase", () => pascalCase(name2)).with("camelCase", () => camelCase(name2)).with("kebab-case", () => kebabCase(name2)).with("snake_case", () => snakeCase(name2)).exhaustive();
    }
    return {
      Program(node) {
        const [basename = "", ...rest] = path__default.default.basename(context.filename).split(".");
        if (basename.length === 0) {
          context.report({ messageId: "filenameEmpty", node });
          return;
        }
        if (validate2(basename)) return;
        context.report({
          messageId: "filenameCaseMismatchSuggestion",
          node,
          data: {
            name: filename,
            rule,
            suggestion: [getSuggestion(basename), ...rest].join(".")
          }
        });
      }
    };
  },
  defaultOptions: defaultOptions2
});
var RULE_NAME3 = "filename-extension";
var defaultOptions3 = [{
  allow: "as-needed",
  extensions: [".jsx", ".tsx"]
}];
var schema3 = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["always", "as-needed"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          allow: {
            type: "string",
            enum: ["always", "as-needed"]
          },
          extensions: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          }
        }
      }
    ]
  }
];
var filename_extension_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce naming convention for JSX file extensions"
    },
    messages: {
      filenameExtensionInvalid: "The JSX file extension is required.",
      filenameExtensionUnexpected: "Use JSX file extension as needed."
    },
    schema: schema3
  },
  name: RULE_NAME3,
  create(context) {
    const options = context.options[0] ?? defaultOptions3[0];
    const allow = tools.isObject(options) ? options.allow : options;
    const extensions = tools.isObject(options) && "extensions" in options ? options.extensions : defaultOptions3[0].extensions;
    const filename = context.filename;
    const hasJSXNodeRef = tools.MutRef.make(false);
    return {
      JSXElement() {
        tools.MutRef.set(hasJSXNodeRef, true);
      },
      JSXFragment() {
        tools.MutRef.set(hasJSXNodeRef, true);
      },
      "Program:exit"(node) {
        const fileNameExt = filename.slice(filename.lastIndexOf("."));
        const isJSXExt = extensions.includes(fileNameExt);
        const hasJSXCode = tools.MutRef.get(hasJSXNodeRef);
        if (hasJSXCode && !isJSXExt) {
          context.report({
            messageId: "filenameExtensionInvalid",
            node
          });
          return;
        }
        if (!hasJSXCode && isJSXExt && allow === "as-needed") {
          context.report({
            messageId: "filenameExtensionUnexpected",
            node
          });
        }
      }
    };
  },
  defaultOptions: defaultOptions3
});
var RULE_NAME4 = "use-state";
function isSetterNameLoose(name2) {
  const fourthChar = [...name2][3];
  return name2.startsWith("set") && fourthChar === fourthChar?.toUpperCase();
}
var use_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce destructuring and symmetric naming of 'useState' hook value and setter variables"
    },
    messages: {
      useState: "An useState call is not destructured into value + setter pair."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    const alias = shared.decodeSettings(context.settings).additionalHooks?.useState ?? [];
    const { ctx, listeners } = core.useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { hookCalls } of components.values()) {
          if (hookCalls.length === 0) continue;
          for (const hookCall of hookCalls) {
            if (!core.isUseStateCall(hookCall, context) && !alias.some(core.isReactHookCallWithNameLoose(hookCall))) {
              continue;
            }
            if (hookCall.parent.type !== types.AST_NODE_TYPES.VariableDeclarator) {
              continue;
            }
            const { id } = hookCall.parent;
            const descriptor = tools.O.some({ messageId: "useState", node: id });
            tools.F.pipe(
              tsPattern.match(id).with({ type: types.AST_NODE_TYPES.Identifier }, tools.F.constant(descriptor)).with({ type: types.AST_NODE_TYPES.ArrayPattern }, (n) => {
                const [state, setState] = n.elements;
                if (state?.type === types.AST_NODE_TYPES.ObjectPattern && setState?.type === types.AST_NODE_TYPES.Identifier) {
                  return isSetterNameLoose(setState.name) ? tools.O.none() : descriptor;
                }
                if (state?.type !== types.AST_NODE_TYPES.Identifier || setState?.type !== types.AST_NODE_TYPES.Identifier) {
                  return tools.O.none();
                }
                const [stateName, setStateName] = [state.name, setState.name];
                const expectedSetterName = `set${capitalize(stateName)}`;
                if (setStateName === expectedSetterName) return tools.O.none();
                return descriptor;
              }).otherwise(tools.O.none),
              tools.O.map(context.report)
            );
          }
        }
      }
    };
  },
  defaultOptions: []
});

// src/index.ts
var src_default = {
  meta: {
    name,
    version
  },
  rules: {
    "component-name": component_name_default,
    filename: filename_default,
    "filename-extension": filename_extension_default,
    "use-state": use_state_default
  }
};

module.exports = src_default;
